= `bin`
:toc: auto
:toclevels: 4
:numbered:
:experimental: true
:icons: font
:source-highlighter: pygments
:pygments-css: class

:toc:

Script collection.  Many of them are written in http://doc.cat-v.org/plan_9/4th_edition/papers/rc[Rc shell], for Bourne-or-Bash-compatible shell suffers from many design flaws, making it difficult to maintain.

This document is written in literate programming style.  To generate scripts and documentation, you need latest stable version of https://github.com/cmpitg/ulquikit[Ulquikit].  You could also clone the repo and start using it yourself.  All executables are in `bin/`.

TODO: Script to display a persistent notification for current desktop

TODO: Explain how commands are built the way they are built below:
* When to pass as argumment?  When to pass into stdin?
* When to output as text?  Human-readable?
* What about exit code?

TODO: Help text for all commands

TODO: fzf integration; use cases: convert-to-* + fzf

TODO: GNU parallel integration

TODO: Write about shell design flaws

== Requirements

For everything to function correctly, you need:

* https://github.com/9fans/plan9port[Plan 9 from User Space] (Plan9port)
* GNU Emacs 26+
* Python 3
* https://www.google.com/get/noto/[Noto Font]

Some scripts depend on others.  It's best to fulfill the requirements for all
of them.

== Notes

My environment is unusual:

* `${HOME}/Data` is either a symlink or a mount point, pointing to all
  configuration and data belonging to the tools I use.
+
If you have a separated `${HOME}`, you just need to create the `Data`
directory.
+
The main reasons why I don't use separated partition for `${HOME}` is because:
1) `${HOME}` itself is extremely inconsistent and cluttered (`.config`,
`.local`, dot files, capticalized names vs. lower-case names, etc.); and 2) I
use serveral distros, where each piece of software is slightly different in
versions, thus different in configuration.
+
In my main system, `/home/cmpitg/Data` is a symlink to `/mnt/home/cmpitg`,
whereas `/mnt/home` is a mount point.

* `${HOME}/Data/Mount-Points` contains a collection of shortcuts to various
  directories, and `/m` is its symlink into `/`.
+
I like to separate the original directories from their shortcuts and to make
things globally visible.  Some might argue that this is a serious security
flaw.  I disagree.  Private things should be kept away.  Your `.ssh` should
never stay in `/m`.

* `/m/${USER}` is a symlink back to `${HOME}/Data`, so all symlinks in `/m`
  can utilize `/m/${USER}` itself.
+
Symlinks are very useful if used appropriately (examples include the
https://nixos.org/nix/[Nix package manager]).  For me, using `/m/src` is much
more effective and unified than `~/src` for `~` depends on what your current
user is.  I could also re-symlink `/m/src` whenever I with minimal effects on
other parts of the system.
+
[source]
----
✗ l /m
lrwxrwxrwx 1 root root 30 Nov 28 20:24 /m -> /home/cmpitg/Data/Mount-Points/

✗ l /m/
total 12K
drwxr-xr-x  4 cmpitg cmpitg 4.0K Nov 28 22:04 ./
drwxr-xr-x 29 cmpitg cmpitg 4.0K Dec  1 23:44 ../
dr-xr-xr-x  1 cmpitg cmpitg    0 Jan  1  1970 9p-fonts/
drwxr-xr-x  2 cmpitg cmpitg 4.0K Nov 23 22:23 acme/
lrwxrwxrwx  1 cmpitg cmpitg   13 Nov 28 22:01 bin -> /m/cmpitg/Bin/
lrwxrwxrwx  1 cmpitg cmpitg   17 Nov 28 20:22 cmpitg -> /home/cmpitg/Data/
lrwxrwxrwx  1 cmpitg cmpitg   16 Feb 15  2015 config -> /m/cmpitg/Config/
lrwxrwxrwx  1 cmpitg cmpitg   13 Nov 28 22:02 opt -> /m/cmpitg/Opt/
lrwxrwxrwx  1 cmpitg cmpitg   17 Aug  3  2014 scratch -> /m/cmpitg/Scratch/
lrwxrwxrwx  1 cmpitg cmpitg   18 Nov 28 22:04 src -> /m/cmpitg/Src/
lrwxrwxrwx  1 cmpitg cmpitg   15 Feb 15  2015 talks -> /m/cmpitg/Talks/
lrwxrwxrwx  1 cmpitg cmpitg   17 Aug  3  2014 toolbox -> /m/cmpitg/Toolbox/
lrwxrwxrwx  1 cmpitg cmpitg   22 Aug  3  2014 virtenvs -> /m/cmpitg/Virtual-Envs/
lrwxrwxrwx  1 cmpitg cmpitg   18 Nov 28 20:35 www -> /m/cmpitg/WWW/
----
+
Most directories should speak for themselves.  Exceptions include:
+
** `/m/9p-fonts`: mounted by Plan9port's `fontsrv` to serve fonts, and
** `/m/acme`: file system interface of Acme.

== Installation

For installation of Plan9port, please refer to
https://github.com/9fans/plan9port[its original documentation].  Below is one
example session for Debian-based distros:

[source,sh]
----
sudo apt install -y build-essential libfreetype6-dev libx11-dev libx11-xcb-dev git libxt-dev xorg-dev xserver-xorg-dev
cd /path/to/src/
git clone https://github.com/9fans/plan9port.git
cd plan9port
./INSTALL

# No need to add plan9port/bin to PATH as the `9` script below is used to
# invoke Plan 9 applications
----

For Emacs, Python, and Noto Font, please consult your distro's documentation.
Example with Debian:

[source,sh]
----
sudo apt install python3 fonts-noto emacs25
----

'''''

== Contents

=== `bash-pure` - runs Bash in a clean environment

.file::bash-pure
[source,sh]
----
#!/usr/bin/env sh

# exec env --ignore-environment - HOME="${HOME}" USER="${USER}" DISPLAY="${DISPLAY}" bash --login --noprofile --norc "$@"
exec bash --noprofile --norc "$@"

----

=== `with-env-pure` - runs a command under `bash-pure`

.file::with-env-pure
[source,sh]
----
#!/usr/bin/env bash-pure

exec "$@"

----

=== `bash-user` - runs Bash with the current user's environment

.file::bash-user
[source,sh]
----
#!/usr/bin/env bash-pure

if [ -f ~/.env ]; then
	. ~/.env
fi
if [ -f ~/.env-prog ]; then
	. ~/.env-prog
fi

exec bash "$@"

----

=== `with-env-user` - runs a command under `bash-user`

.file::with-env-user
[source,sh]
----
#!/usr/bin/env bash-user

exec "$@"

----

=== `conda/` - utils for Python https://docs.conda.io/en/latest/[Conda]

==== `conda/with-env` - runs a command in the Conda environment

.file::conda/with-env
[source,sh]
----
#!/usr/bin/env bash

CONDA_PATH="${CONDA_PATH:-/m/opt/miniconda3}"
export PATH="${CONDA_PATH}/bin:${PATH}"

if ! report-missing-executables conda Conda; then
	exit 1
fi

eval "$(${CONDA_PATH}/bin/conda shell.bash hook)"

exec "$@"

----

=== `guix/` - utils for http://guix.gnu.org/[the Guix package manager]

==== `guix/with-env` - runs a command in the Guix environment

.file::guix/with-env
[source,sh]
----
#!/usr/bin/env bash-user

set +x

# Do not re-read user env
export _READ_USER_ENV_=0

export GUIX_LOCPATH="${HOME}/.guix-profile/lib/locale"
export GUIX_LD_WRAPPER_ALLOW_IMPURITIES=n

export PATH="${HOME}/.config/guix/current/bin:${PATH}"
export INFOPATH="${HOME}/.config/guix/current/share/info:${INFOPATH}"
export GUIX_PROFILE="${HOME}/.guix-profile"
[[ -e "${HOME}/.config/guix/current/etc/profile" ]] && . "${HOME}/.config/guix/current/etc/profile"
[[ -e "${HOME}/.guix-profile/etc/profile" ]] && . "${HOME}/.guix-profile/etc/profile"

XDG_DATA_DIRS="${XDG_DATA_DIRS:-${HOME}/.local/share}"
XDG_DATA_DIRS="${XDG_DATA_DIRS}:/usr/share:/usr/local/share:${HOME}/.local/share"
export XDG_DATA_DIRS

unset _READ_USER_ENV_

exec "$@"

----

=== `chruby/` - utils for https://github.com/postmodern/chruby[`chruby`]

==== `with-env` - runs a command in `chruby` environment

.file::chruby/with-env
[source,sh]
----
#!/usr/bin/env bash

if [[ -z "${RUBY_CHRUBY_VERSION}" ]]; then
	echo "RUBY_CHRUBY_VERSION not defined, aborting..." >&2
	exit 3
fi

# Only run with Bash or Zsh
if [[ -n "${BASH}" || -n "${ZSH_NAME}" ]]; then
	. /usr/local/share/chruby/chruby.sh
	. /usr/local/share/chruby/auto.sh
	export -f chruby
	chruby ${RUBY_CHRUBY_VERSION}
fi

"$@"

----

=== `sh` - utils for shell scripting

==== `print-colors` - print all colors

.file::sh/print-colors
[source,sh]
----
#!/usr/bin/env bash

for i in {0..255}; do
	printf "\x1b[38;5;${i}mcolour${i}\x1b[0m\n"
done

----

=== `git` - utils for Git version control

==== `rm-orphaned` - removes orphaned files

.file::git/rm-orphaned
[source,sh]
----
#!/usr/bin/env sh

git ls-files --deleted | xargs git rm --cached

----

==== `git/show-merge-diff` - `diff`s as if a merge is to be performed

TODO:
* Help text
* Error if missing arguments

.file::git/show-merge-diff
[source,sh]
----
#!/usr/bin/env sh

base_branch_="${1}"
head_branch_="${2}"

git merge-tree $(git merge-base "${base_branch_}" "${head_branch_}") "${base_branch_}" "${head_branch_}"

----

=== `graalvm/` - utils for https://www.graalvm.org/[GraalVM]

==== `with-env` - runs a command with Java from GraalVM

.file::graalvm/with-env
[source,sh]
----
#!/usr/bin/env bash

export JAVA_HOME=/m/opt/graalvm
export PATH="${JAVA_HOME}/bin:${PATH}"

exec "$@"

----

=== `inferno/` - utils for http://www.vitanuova.com/inferno/[Inferno OS]

==== `with-env` - runs a command with Inferno OS environment

.file::inferno/with-env
[source,sh]
----
#!/usr/bin/env bash

set -o nounset

export EMU='-g800x600 -c1'
export PATH="${INFERNO_OS_ROOT}/Linux/386/bin:${PATH}"

exec "$@"

----

==== `start-emu` - starts the emulator with some config

.file::inferno/start-wm
[source,sh]
----
#!/usr/bin/env sh

set -o nounset

export user=cmpitg

exec emu /dis/wm/wm.dis wm/logon -n "/usr/${user}/namespace" -u "${user}" "$@"

----

=== `with-pause` - runs a command, then pause and wait for user to input Enter to exit

.file::with-pause
[source,sh]
----
#!/usr/bin/env bash

"$@"
read -p "Press Enter to exit..."

----

=== `9` - sets up the environment for Plan9port applications

* Starts and mounts 9p font server to `/m/9p-fonts`
* Creates temporary directory: `/tmp/9-${USER}`
* And executes a command in a Plan9port environment in `${PLAN9}/bin`.  If `PLAN9` variable is not set, it is set to `/m/opt/plan9port` by default.

.file::9
[source,sh]
----
#!/usr/bin/env bash

##
## Sets up the environment for Plan9port applications:
## * Starts plumber and font server
## * Runs the corresponding program
##

export TEMP9=/tmp/9-${USER}
export PLAN9=/m/opt/plan9port
export PATH=${PLAN9}/bin:${PATH}

export SHELL=rc
export TERM=9term
export font='/m/9p-fonts/GoMono/11a/font'

mkdir -p ${TEMP9}
mkdir -p /m/9p-fonts

running-p plumber || plumber
running-p fontsrv || \
	nohup fontsrv \
		-m /m/9p-fonts \
		>${TEMP9}/fontsrv.out \
		2>${TEMP9}/fontsrv.err &

exec ${PLAN9}/bin/9 "$@"

----

=== `with-retry <timeout> <times> <cmd>...` - runs a command, retrying on error

TODO: Help text

.file::with-retry
[source,tcl]
----
#!/usr/bin/env tclsh

set timeout [lindex $::argv 0]
set times [lindex $::argv 1]
set cmd [lrange $::argv 2 end]

proc execCmd {cmd} {
    return [exec {*}$cmd <@ stdin >@ stdout 2>@ stderr]
}

if {[catch {execCmd $cmd}]} {
    while {$times > 0} {
        puts stderr [format "Command failed, retrying (times=%s) after %sms" $times $timeout...]
        after $timeout
        if {[catch {execCmd $cmd}]} {
            incr times -1
        } else {
            exit 0
        }
    }
    exit 1
} else {
    exit 0
}

----

=== `9-term` - runs Plan9port terminal emulator within a 9 environment

.file::9-term
[source,sh]
----
#!/usr/bin/env sh

#
# Starts 9term within an Rc environment.
#

exec 9 9term $*

----

=== `rc` - runs RC shell with Plan 9 Port environment

.file::rc
[source,sh]
----
#!/usr/bin/env bash

exec 9 rc "$@"

----

=== `acme` - runs Plan9port Acme with `9`

Font can be chosen by setting the `font` environment variable.  By default, it
is set to `/m/9p-fonts/Go Mono/11a/font`.

.file::acme
[source,sh]
----
#!/usr/bin/env rc

#
# Starts Acme with font specified by variable `font'.  By default, use Droid
# Sans Mono.
#

if (~ $font '') {
	font='/m/9p-fonts/GoMono/11a/font'
}

mkdir -p /m/acme

acme -a \
	-m /m/acme \
	-f $font $* $toolbox

----

=== `term-emu` - wrapper for terminal emulator

.file::term-emu
[source,sh]
----
#!/usr/bin/env sh

# Terminator has some memory leaks, throws GTK error messages to the console
# GNOME terminal doesn't handle mouse scrolling well
# XFCE4 terminal crashes randomly (under load?)
# konsole -e <cmd>
# xfce4-terminal -x <cmd>

term_emu_="${MY_TERM_EMU:-konsole}"

exec "${term_emu_}" -e "$@"

----

=== `with-term-emu` - runs a command in a termimal emulator

TODO: Document: with/out termux
TODO: Document: session & window naming
TODO: Document: must use double quoting:
* This works: awesome-client "'get_something'"
* Does this doesn't: awesome-client "'get_something'"
How to prevent the double quoting?
`with-env-user "$@"` works but cannot chain shell commands since everything becomes the argument for with-env-user, not part of the shell

.file::with-term-emu
[source,sh]
----
#!/usr/bin/env sh

if [ "${WITHOUT_TERMUX}" = "1" ]; then
	unset WITHOUT_TERMUX
	exec term-emu "/usr/bin/env with-env-user $*"
else
	window_name_=$(echo "$@" | sed "s/:/COLON/g ; s/\./DOT/g ; s/(/OPEN/g ; s/)/CLOSE/g")
	if [ "${DETACH_TERMUX}" = "1" ]; then
		unset DETACH_TERMUX
		exec term-emu with-termux -n "${window_name_}" "with-env-user $*" \; detach
	else
		unset DETACH_TERMUX
		exec term-emu with-termux -n "${window_name_}" "with-env-user $*"
	fi
fi

----

=== `with-term-emu-detach` - runs and detachs a command in a termimal emulator

.file::with-term-emu-detach
[source,sh]
----
#!/usr/bin/env sh

exec env WITHOUT_TERMUX="${WITHOUT_TERMUX}" DETACH_TERMUX=1 with-term-emu "$@"

----

=== `with-termux` - runs a command with a terminal multiplexer

.file::with-termux
[source,sh]
----
#!/usr/bin/env sh

exec tmux new-session "$@"

----

=== `bring-termux-session` - brings a terminal emulator session here

.file::bring-termux-session
[source,sh]
----
#!/usr/bin/env sh

exec env WITHOUT_TERMUX=1 with-term-emu tmux attach -t "$@"

----

=== `note-taker` - runs a note taker

.file::note-taker
[source,sh]
----
#!/usr/bin/env sh

exec chromium --app=https://notion.so "$@"

----

=== `newline`

.file::newline
[source,sh]
----
#!/usr/bin/env sh

printf "\n"
----

=== `gnu-awk` - specifically calls the GNU implementation of Awk

.file::gnu-awk
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables gawk "GNU Awk" || exit 1

exec gawk "$@"

----

=== `gnu-sed` - specifically calls the GNU implementation of sed

.file::gnu-sed
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables sed "GNU sed" || exit 1

if (/bin/sed --version 2>/dev/null | head -1 | grep sed &>/dev/null); then
	exec /bin/sed "$@"
elif (sed --version 2>/dev/null | head -1 | grep sed &>/dev/null); then
	exec sed "$@"
else
	echo You don\'t have GNU sed installed. >&2
	exit 1
fi

----

=== `gnu-tar` - specifically calls the GNU implementation of Tar

.file::gnu-tar
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tar "GNU tar" || exit 1

if (/bin/tar --version 2>/dev/null | head -1 | grep tar &>/dev/null); then
	exec /bin/tar "$@"
elif (tar --version 2>/dev/null | head -1 | grep tar &>/dev/null); then
	exec tar "$@"
else
	echo You don\'t have GNU tar installed. >&2
	exit 1
fi

----

=== `gnu-tr` - attempts to call the GNU implementation of tr

.file::gnu-tr
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tar "GNU tr" || exit 1

if (/bin/tr --version 2>/dev/null | head -1 | grep tr &>/dev/null); then
	exec /bin/tr "$@"
elif (/usr/bin/tr --version 2>/dev/null | head -1 | grep tr &>/dev/null); then
	exec /usr/bin/tr "$@"
else
	echo You don\'t have GNU tr installed. >&2
	exit 1
fi

----

=== `upcase` - upcases a string (read from stdin)

.file::upcase
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tr "GNU tr" || exit 1

exec gnu-tr '[:lower:]' '[:upper:]'

----

=== `downcase` - downcases a string (read from stdin)

.file::downcase
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tr "GNU tr" || exit 1

exec gnu-tr '[:upper:]' '[:lower:]'

----

=== `view-man` - views a Man page in a GUI pager (Rmacs)

.file::view-man
[source,sh]
----
#!/usr/bin/env tclsh

set page [lindex $::argv 0]

exec rmacs --new-frame eval "(let ((frame (selected-frame)))
  (man \"$page\")
  (delete-frame frame)
  (setq-local local/delete-frame-on-close t))" <@ stdin >@ stdout 2>@ stderr

----

=== `rmacs-pager` - uses Rmacs GUI as a poor man's pager

TODO: Description and potential improvement

.file::rmacs-pager
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require fileutil 1.15

set tempPath [::fileutil::tempfile]
set tempBufferName [exec random-string]

if {$::argc == 0} {
	set serverName pager
} else {
	set serverName [lindex $::argv 0]
}

exec cat > $tempPath <@ stdin
exec rmacs --name $serverName --new-frame eval "(with-current-buffer (get-buffer-create \"$tempBufferName\")
  (insert-file \"$tempPath\")
  (delete-file \"$tempPath\" nil)
  (setq-local local/delete-frame-on-close (selected-frame))
  (Man-cleanup-manpage)
  ;; (Man-fontify-manpage)
  (switch-to-buffer (current-buffer)))" >@ stdout 2>@ stderr

----

=== `rmacs-tee` - tee's to an Rmacs buffer

TODO: Description

.file::rmacs-tee
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require fileutil 1.15

set serverName [lindex $::argv 0]
set bufferName [lindex $::argv 1]

set bufferSize 4096
set tempPath [::fileutil::tempfile]

proc spit {path content} {
    set fd [open $path w]
    puts -nonewline $fd $content
    close $fd
}

while {![eof stdin]} {
    set input [read stdin $bufferSize]
    puts -nonewline $input
    spit $tempPath $input
    exec rmacs --name $serverName eval "(with-current-buffer (get-buffer-create \"$bufferName\")
  (save-excursion
    (goto-char (point-max))
    (insert-file \"$tempPath\")))
  " 2>@ stderr
}

file delete $tempPath

----

=== `cat-which <executable>` - `cat $(which executable-1 [executable-2] [...])`

.file::cat-which
[source,sh]
----
#!/usr/bin/env bash

#
# Finds full path executables and displays the content.
#


for exec_ in "$@"; do
	if $(which "${exec_}" &>/dev/null); then
		cat $(which "${exec_}")
	else
		echo "${exec_} not found" >&2
	fi
done

----

=== `check-broken-symlinks [path1] [path2] [...]`

.file::check-broken-symlinks
[source,sh]
----
#!/usr/bin/env bash

#
# Checks for broken symlinks.
#

for file_ in "$@" ; do
	if [ -L "${file_}" ]; then
		if readlink -q "${file_}" >/dev/null ; then
			echo "Good link: ${file_}"
		else
			echo "${file_}: bad link" >/dev/stderr
		fi
	else
		echo "${file_} is not a symlink"
	fi
done

----

=== `buildapp-cmpitg` - builds Common Lisp standalone executable

With https://github.com/xach[@xach's]
http://www.xach.com/lisp/buildapp/[Buildapp].  This script takes
https://common-lisp.net/project/asdf/[ASDF] manifest file from `manifest`
environment variable.  By default, `manifest` is set to
`/m/config/common-lisp/sbcl-quicklisp-manifest.txt`.

.file::buildapp-cmpitg
[source,sh]
----
#!/usr/bin/env rc

if (~ $manifest '') {
	manifest='/m/config/common-lisp/sbcl-quicklisp-manifest.txt'
}

buildapp --manifest-file $manifest \
	--load /m/config/common-lisp/sbcl-base.lisp \
	$*

----

=== `symlink` - symlinks, prompting for overwriting if destination exists

.file::symlink
[source,sh]
----
#!/usr/bin/env sh

if [ "$#" -eq 1 ] && [ "${1}" = "--help" ]; then
	echo "Usage: ${0} <source> <destination>

Symlink <source> to <destination>.  If <destination> ends with a slash (/), it indicates a directory and the symlink is put in the directory.  Otherwise, prompt for overwriting <destination> if exists.  In case that <source> is a symlink, it is not followed."
	exit 0
fi

if [ "$#" -ne 2 ]; then
	echo "${0} requires 2 arguments: <source> and <destination>" >&2
	exit 2
fi

if [ -d "${2}" ] && [ ! -L "${2}" ]; then
	exec ln --interactive --verbose --symbolic "${1}" "${2}"
else
	exec ln --interactive --verbose --symbolic --no-target-directory "${1}" "${2}"
fi

----

=== `start-vpn` - connects to a VPN

Connects to a VPN using OpenVPN, taking the first argument as the path to the directory that contains the VPN configuration.  This script will automatically start the client VPN process in a Tmux session if not run in a TTY.

.file::start-vpn
[source,sh]
----
#!/usr/bin/env sh

vpn_dir_="${1:-${HOME}}"
vpn_path_=$(zenity --file-selection --multiple --filename="${vpn_dir_}")

if [ -n "${vpn_path_}" ]; then
	start_vpn_cmd_="cd $(dirname ${vpn_path_}) && sudo openvpn --config ${vpn_path_}"
    cd "$(dirname ${vpn_path_})"

	if [ -t 0 ]; then
		eval "${start_vpn_cmd_}"
	else
		term-emu "tmux new-session 'bash -c \"${start_vpn_cmd_}\"'"
	fi
fi

----

=== `list-broken-symlinks` - lists broken symlinks in a directory

TODO: `--help`

.file::list-broken-symlinks
[source,sh]
----
#!/usr/bin/env sh

dir_=$(readlink -f "${1:-.}")

for file_ in "${dir_}/"*; do
    if [ ! -e "${file_}" ]; then
        echo "${file_}"
    fi
done

----

=== `check-xinput` - checks if a device appears in `xinput list`

.file::check-xinput
[source,sh]
----
#!/usr/bin/env bash

set -o nounset

DISPLAY=${DISPLAY:-:0}

exec xinput list | grep "$@" >/dev/null 2>&1
----

=== `wait-for-xinput` - waits until an xinput device is available

TODO: Docstring

.file::wait-for-xinput
[source,sh]
----
#!/usr/bin/env bash

set -o nounset

DISPLAY=${DISPLAY:-:0}

timeout_=${TIMEOUT:-0.1}
times_=${TIMES:-50}
counter_=0

while ! $(check-xinput "$@"); do
	counter_=$((counter_ + 1))
	if [[ "${counter_}" = "${times_}" ]]; then
		exit 1
	fi
	sleep "${timeout_}"
done

----

=== `chmod-default [dir]` - fixes permissions

`chmod` a directory recursively, 755 for files and 644 for directories.  By
default, `dir` is current working directory.

.file::chmod-default
[source,sh]
----
#!/usr/bin/env bash

test -z "$1" && dir_="." || dir_="$1"

find "${dir_}" -type d -print0 | xargs -0 chmod 0755
find "${dir_}" -type f -print0 | xargs -0 chmod 0644

----

=== `cl-write-manifest` - writes ASDF manifest file

Writes
https://common-lisp.net/project/asia/asia.html#_how_to_create_project_manifest_database[ASDF
manifest] file to a location, set by environment variable `manifest`.  By
default, `manifest` is set to
`/m/config/common-lisp/sbcl-quicklisp-manifest.txt`.

.file::cl-write-manifest
[source,sh]
----
#!/usr/bin/env rc

if (~ $manifest '') {
	manifest='/m/config/common-lisp/sbcl-quicklisp-manifest.txt'
}

echo Writing manifest file $manifest

sbcl-cmpitg --no-userinit --no-sysinit --non-interactive \
	--eval '(ql:write-asdf-manifest-file "'^$manifest^'")'

----

=== `clojure-repl` - starts Clojure REPL with http://leiningen.org/[Lein]

Starts a Clojure REPL in a directory, set by the `clojure_root` environment
variable.  By default, `clojure_root` is set to `${HOME}/test/clojure/main`.

.file::clojure-repl
[source,sh]
----
#!/usr/bin/env rc

if (~ $clojure_root '') {
	clojure_root=$home/test/clojure/main
}

pushd .
cd $clojure_root
lein repl $@
popd

----

=== `comment-code` - comments code, read from stdin

Comments code by prefixing them with line comment character string by the
first argument passed in this script.  By default, prefix code with `# `.

.file::comment-code
[source,sh]
----
#!/usr/bin/env rc

#
# Comments a piece of code.
#

if (~ $1 '') {
	comment_char='#'
}
if not {
	comment_char=$1
}

prefix $comment_char^' '

----

=== Keyboard layout

Notes:

* Pressing a button → kernel generates a *keycode* → X receives the keycode and looks up a *keysym* that is mapped to that keycode

* When using the `xmodmap` command to modify the keyboard layout, note that:

** `clear`, `add`, and `remove` are for modifiers

** To remap modifiers, first we need to remove the old mapping, then assign them again.

** Swapping modifiers general involves 3 steps:
*** Removing the current mapping for the modifiers
*** Swapping the keysyms - it's generally better to not touch the keycodes (to maintain compatibility with different vendors, e.g. one keysym might produced from different keycodes from different keyboard vendors)
*** Re-adding the same mapping for the modifiers

** An example to demonstrate how the key mapping and translation work:
+
[source,xmodmap]
----
! To map a physical key to a targeted key
keysym <physical-key> = <targeted-key>
! After this key, pressing the physical key will generate keysym for the targeted key

! When mapping a modifier, we only care about the targeted key
add <modifier> = <targeted-key>
----

** Common modifier terms:
*** `control` is for Control
*** `mod1` is for Alt/Meta
*** `mod2` is for NumLock
*** `mod4` is for Super
*** `mod5` is for ISO 3rd Level or Mode Switch

==== `config-keymap-altgr` - keyboard layout: Programmer Dvorak + Right Alt as AltGr + Ctrl-Alt swapped + CapsLock-Escape swapped

.file::config-keymap-altgr
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

do-notify-short "Setting cmpitg's keyboard layout with Right Alt as AltGr"
setxkbmap us -variant dvp
xmodmap <( cat <<EOF
!
! No mod5 by default
!

clear mod5

!
! Swap Escape and Capslock keysyms
!

remove Lock = Caps_Lock
keysym Caps_Lock = Escape
keysym Escape = Caps_Lock
add Lock = Caps_Lock

!
! Swap left Ctrl and Alt
!

remove control = Control_L
remove mod1 = Alt_L Meta_L
keysym Control_L = Alt_L
keysym Alt_L = Control_L
add control = Control_L
add mod1 = Alt_L

!
! Set right Ctrl as right Alt and right Alt as ISO 3rd level
!

remove control = Control_R
remove mod1 = Alt_R Meta_R
keysym Alt_R = Control_R
keysym Control_R = ISO_Level3_Shift
add control = Control_R
add mod5 = ISO_Level3_Shift

! Local Variables:
! comment-start: "!"
! End:

EOF
)

----

==== `config-keymap-standard` - keyboard layout: Programmer Dvorak + Ctrl-Alt swapped + CapsLock-Escape swapped

.file::config-keymap-standard
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

##############################################################################

do-notify-short "Setting cmpitg's keyboard layout"
setxkbmap us -variant dvp
xmodmap <( cat <<EOF
! -*- mode: xmodmap-generic -*-
!
! Notes:
!
! * Press a button -> kernel generates a keycode -> maps to a keysym
!
! * 'clear', 'add', and 'remove' are for modifiers
!
! * To remap modifiers, first we need to remove the old keysyms, then assign them again.  That's why swapping is three-step:
!   - Remove current mapping for modifiers
!   - Swap the keysyms
!   - Re-add the same mapping for modifiers
!
! * 'keysym' is to map keysym.  Generally, it's better to only touch keysyms.
!
! * Modifiers:
!   - 'control' is for Control
!   - 'mod1' is for Alt/Meta
!   - 'mod2' is for NumLock
!   - 'mod4' is for Super
!   - 'mod5' is for ISO 3rd Level or Mode Switch
!
!            |  Keycode |    Keysym
!------------|----------|-----------
! Left  CTRL |       37 | Control_L
! Left   ALT |       64 |     Alt_L
! Right CTRL |      105 | Control_R
! Right  ALT |      108 |     Alt_R
!   Capslock |       66 | Caps_Lock
!     Escape |        9 |    Escape
!

!
! No mod5 by default
!

clear mod5

!
! Swap Escape and Capslock keysyms
!

remove Lock = Caps_Lock
keysym Caps_Lock = Escape
keysym Escape = Caps_Lock
add Lock = Caps_Lock

!
! Swap left Ctrl and Alt
!

remove control = Control_L
remove mod1 = Alt_L Meta_L
keysym Control_L = Alt_L
keysym Alt_L = Control_L
add control = Control_L
add mod1 = Alt_L

!
! Swap right Ctrl and Alt
!

remove control = Control_R
remove mod1 = Alt_R Meta_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R
add control = Control_R
add mod1 = Alt_R

! Local Variables:
! comment-start: "!"
! End:

EOF
)

----

=== `config-inputs-cmpitg` - config keyboards, mice, ... all input devices

.file::config-inputs-cmpitg
[source,sh]
----
#!/usr/bin/env bash

# config-keymap-standard
config-keymap-altgr
config-logitech-trackball-marble-righty
# config-logitech-trackball-marble-lefty
config-logitech-mx-ergo-right
config-logitech-g300-mouse
config-logitech-g502-mouse
config-lenovo-n700-mouse
config-touchpad
config-extra-peripherals

----

=== `config-keymap-steam` - keyboard layout: Programmer Dvorak without AltGr

Because Steam doesn't work with swapped modifiers.

.file::config-keymap-steam
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

do-notify-short "Setting keyboard layout for Steam"
newline
setxkbmap us -variant dvp
xmodmap <( cat <<EOF
!
! No mod5 by default
!

clear mod5

!
! Swap left Ctrl and Alt
!

remove control = Control_L
remove mod1 = Alt_L Meta_L
keysym Control_L = Alt_L
keysym Alt_L = Control_L
add control = Control_L
add mod1 = Alt_L

!
! Set right Ctrl as right Alt and right Alt as ISO 3rd level
!

remove control = Control_R
remove mod1 = Alt_R Meta_R
keysym Alt_R = Control_R
keysym Control_R = ISO_Level3_Shift
add control = Control_R
add mod5 = ISO_Level3_Shift

EOF
)

config-logitech-g502-mouse
config-logitech-mx-ergo-right

----

=== Config mouses & extra peripherals

Enables natural scrolling and tweaks acceleration profile.

==== `config-extra-peripherals`

.file::config-extra-peripherals
[source,sh]
----
#!/usr/bin/env bash

check-xinput 'DELL Laser Mouse' && (
	do-notify "Setting natural scrolling for Dell mouse"
	(
		xinput set-prop 'DELL Laser Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
		xinput set-prop 'DELL Laser Mouse' 'libinput Accel Speed' 0.2 &>/dev/null
	) || (
		xinput set-prop 'DELL Laser Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'Logitech USB Optical Mouse' && (
	do-notify 'Setting accel profile for Logitech USB Optical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'PS/2 Synaptics TouchPad' 'Device Accel Profile' 2
	xinput set-prop 'Logitech USB Optical Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Logitech USB Optical Mouse"
	(
		xinput set-prop 'Logitech USB Optical Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech USB Optical Mouse' 'Evdev Scrolling Distance' -1, -1, 1
	)
)

check-xinput 'Kingsis Peripherals Evoluent VerticalMouse 4' && (
	do-notify "Setting natural scrolling for Evoluent Vertical 4"
	(
		xinput set-prop 'Kingsis Peripherals Evoluent VerticalMouse 4' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Kingsis Peripherals Evoluent VerticalMouse 4' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'MOSART Semi. 2.4G Wireless Mouse' && (
	do-notify 'Setting accel profile for Anker Vertical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Anker Vertical mouse"
	(
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'MOSART Semi. 2.4G Wireless Mouse Mouse' && (
	do-notify 'Setting accel profile for Anker Vertical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Anker Vertical mouse"
	(
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'TPPS/2 IBM TrackPoint' && (
	do-notify "Setting natural scrolling for TPPS/2 IBM TrackPoint"
	(
		xinput set-prop 'TPPS/2 IBM TrackPoint' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'TPPS/2 IBM TrackPoint' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'PS/2 Synaptics TouchPad' && (
	do-notify 'Setting accel profile for PS/2 Synaptics TouchPad'
	# Polynomial - very usable, recommended
	xinput set-prop 'PS/2 Synaptics TouchPad' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for PS/2 Synaptics TouchPad'
	(
		xinput set-prop 'PS/2 Synaptics TouchPad' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation' 1
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation Button' 2
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation Axes' 7, 6, 5, 4
	)
)

check-xinput 'Logitech MX Vertical Advanced Ergonomic Mouse' && (
	do-notify 'Setting accel profile for Logitech MX Vertical Advanced Ergonomic Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for Logitech MX Vertical Advanced Ergonomic Mouse'
	(
		xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'Evdev Scrolling Distance' -1, -1, -1
	)
)

check-xinput 'Logitech MX Vertical' && (
	do-notify 'Setting accel profile for Logitech MX Vertical'
	# Polynomial - very usable, recommended
	xinput set-prop 'Logitech MX Vertical' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for Logitech MX Vertical'
	(
		xinput set-prop 'Logitech MX Vertical' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech MX Vertical' 'Evdev Scrolling Distance' -1, -1, -1
	)
)

----

==== `config-lenovo-n700-mouse`

.file::config-lenovo-n700-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

id_=$( \
	xinput list 2>/dev/null \
	| grep "Dual Mode WL Touch Mouse N700" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

##############################################################################

do-notify-short "Configuring Dual Mode WL Touch Mouse N700
* Set natural scrolling
* Set pointer acceleration
"
{
	xinput set-prop "${id_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
} || {
	xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
}

xinput set-prop "${id_}" "Device Accel Profile" 7

----

==== `config-logitech-g300-mouse`

Also, resets keyboard layout for G300 back to US QWERTY, so that
kbd:[Ctrl+X/C/V] works as expected.

.file::config-logitech-g300-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

mouse_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G300" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)
keyboard_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G300" \
	| tail -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${mouse_}"    && exit 0
test -z "${keyboard_}" && exit 0

##############################################################################

do-notify-short "Configuring Logitech G300 mouse
* Set natural scrolling
* Reset keyboard layout
"
{
	xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
} || {
	xinput set-prop "${mouse_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
}
setxkbmap us -device "${keyboard_}"

----

==== `config-logitech-g502-mouse`

.file::config-logitech-g502-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

# http://www.x.org/wiki/Development/Documentation/PointerAcceleration/

##############################################################################

ids_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G502" \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${ids_}" && exit 0

##############################################################################

do-notify "Configuring Logitech G502 mouse
* Set natural scrolling
* Tuning mouse movement"

for mouse_ in ${ids_}; do
	echo "${mouse_}"

	{
		xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
	} || {
		xinput set-prop "${mouse_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
	}

	xinput set-prop "${mouse_}" "Device Accel Profile" 7
	xinput set-prop "${mouse_}" "Device Accel Constant Deceleration" 2
	xinput set-prop "${mouse_}" "Device Accel Adaptive Deceleration" 1
done

----

==== `config-logitech-mx-ergo-right`

.file::config-logitech-mx-ergo-right
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

# http://www.x.org/wiki/Development/Documentation/PointerAcceleration/

##############################################################################

ids_=$( \
	xinput list \
	| grep "Logitech MX Ergo" \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${ids_}" && exit 0

##############################################################################

do-notify "Configuring Logitech MX Ergo
* Set natural scrolling
* Tuning mouse movement"

# Ref: https://www.x.org/wiki/Development/Documentation/PointerAcceleration/

for mouse_ in ${ids_}; do
	echo "${mouse_}"

	{
		xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
	} || {
		xinput set-prop "${mouse_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
		xinput set-prop "${mouse_}" "Evdev Axis Inversion" 1, 1 &>/dev/null
	}

	xinput set-prop "${mouse_}" "Device Accel Profile" 7
	xinput set-prop "${mouse_}" "Device Accel Constant Deceleration" 1.2
	xinput set-prop "${mouse_}" "Device Accel Adaptive Deceleration" 1.1
done

----

==== `config-logitech-trackball-marble-lefty`

.file::config-logitech-trackball-marble-lefty
[source,sh]
----
#!/usr/bin/env bash

# Sources:
#   https://wiki.archlinux.org/index.php/Logitech_Marble_Mouse
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
#   http://www.x.org/archive/X11R7.5/doc/man/man4/evdev.4.html
#   man evdev

id_=$( \
	xinput list \
	| grep "Logitech USB Trackball" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

# ID        Hardware Action         Result
# 1     Large button left   normal click
# 2     Both large buttons  middle-click  †
# 3     Large button right  right-click
# 4     (not a button)  -
# 5     (not a button)  -
# 6     (not a button)  -
# 7     (not a button)  -
# 8     Small button left   browser back
# 9     Small button right  browser forward


# * big-left: Primary click
# * big-right: Secondary click
# * small-left: Scrolling
# * small-right: Middle click
do-notify-short """Config buttons for lefties:
   large-left  [1]: Right click
   large-right [3]: Left click
   small-left  [8]: Middle click
   small-right [9]: Scrolling + Middle click"""
newline
# xinput set-button-map "${id_}" 1 9 3 4 5 6 7 2 9
xinput set-button-map "${id_}" 3 9 1 4 5 6 7 2 2

# small-left
# xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 8
xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 9

# Enable wheel emulation
xinput set-prop "${id_}" "Evdev Wheel Emulation"        1

##############################################################################

do-notify-short "Config inverted and horizontial scrolling"

# For normal scrolling
# xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 6 7 4 5

# Inverted scrolling
xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 7 6 5 4

# Inverted direction
xinput set-prop "${id_}" "Evdev Axis Inversion" 1 1

##############################################################################

do-notify-short "Config profile: Fast movement but more control at pixel-level"
newline

# Default
# Debian
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5
xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5

# More precision
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 5
xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 1

# Acceleration
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
# xinput set-prop "${id_}" "Device Accel Profile" -1
# xinput set-prop "${id_}" "Device Accel Profile" 6
xinput set-prop "${id_}" "Device Accel Profile" 2
# Debian
xinput set-prop "${id_}" "Device Accel Velocity Scaling" 5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1

----

==== `config-logitech-trackball-marble-righty`

.file::config-logitech-trackball-marble-righty
[source,sh]
----
#!/usr/bin/env bash

# Sources:
#   https://wiki.archlinux.org/index.php/Logitech_Marble_Mouse
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
#   http://www.x.org/archive/X11R7.5/doc/man/man4/evdev.4.html
#   man evdev

id_=$( \
	xinput list \
	| grep "Logitech USB Trackball" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

# ID        Hardware Action         Result
# 1     Large button left   normal click
# 2     Both large buttons  middle-click  †
# 3     Large button right  right-click
# 4     (not a button)  -
# 5     (not a button)  -
# 6     (not a button)  -
# 7     (not a button)  -
# 8     Small button left   browser back
# 9     Small button right  browser forward


# * big-left: Primary click
# * big-right: Secondary click
# * small-left: Scrolling
# * small-right: Middle click
do-notify-short """Config buttons for righties:
   large-left  [1]: Left click
   large-right [3]: Right click
   small-left  [8]: Middle click
   small-right [9]: Scrolling + Middle click"""
newline
xinput set-button-map "${id_}" 1 9 3 4 5 6 7 2 9
# xinput set-button-map "${id_}" 3 9 1 4 5 6 7 2 2

# small-left
xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 8
# xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 9

# Enable wheel emulation
xinput set-prop "${id_}" "Evdev Wheel Emulation"        1

##############################################################################

do-notify-short "Config inverted and horizontial scrolling"
newline

# For normal scrolling
# xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 6 7 4 5

# Inverted scrolling
xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 7 6 5 4

# Inverted direction
xinput set-prop "${id_}" "Evdev Axis Inversion" 1 1
# xinput set-prop "${id_}" "Evdev Axis Inversion" 0 1

##############################################################################

do-notify-short "Config profile: Fast movement but more control at pixel-level"
newline

# Default
# Debian
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5

# More precision
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 5
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 1

# Acceleration
# xinput set-prop "${id_}" "Device Accel Profile" -1
# xinput set-prop "${id_}" "Device Accel Profile" 6
xinput set-prop "${id_}" "Device Accel Profile" 2
# Debian
xinput set-prop "${id_}" "Device Accel Velocity Scaling" 5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1.5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1

----

==== `config-touchpad`

Lots of tweaks, the code should be self-explanatory though.

.file::config-touchpad
[source,sh]
----
#!/usr/bin/env bash

check-xinput -i "touchpad" || exit 0

id_=$( \
	xinput list \
	| grep -i 'synaptics touchpad' \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

scrolling_distance_2_=$(xinput list-props ${id_} \
	| grep 'Synaptics Scrolling Distance' \
	| gnu-awk '{ print $NF }' \
	| sed 's/-//g' \
)
scrolling_distance_1_=$(xinput list-props ${id_} \
	| grep 'Synaptics Scrolling Distance' \
	| gnu-awk '{ print $(NF - 1) }' \
	| cut -d',' -f1 \
	| sed 's/-//g' \
)

##############################################################################

do-notify-short """Configuring touchpad
* Setting natural scrolling
* Enabling tapping
* Enabling two-finger tapping as secondary click"""
newline

# Edge
# synclient LeftEdge=1200
# synclient RightEdge=5100
# synclient TopEdge=1000
# synclient BottomEdge=4600

# synclient LeftEdge=1000
# synclient RightEdge=5200
# synclient TopEdge=1000
# synclient BottomEdge=5000

# Palm detection
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient PalmDetect=1

# Tap
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient MaxTapTime=180
# synclient MaxTapMove=221
# synclient MaxDoubleTapTime=100
# synclient SingleTapTimeout=180
# synclient EmulateTwoFingerMinZ=1
# synclient EmulateTwoFingerMinW=7
# synclient VertEdgeScroll=1
# synclient HorizEdgeScroll=1

# Corner
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient RTCornerButton=0
# synclient RBCornerButton=0
# synclient LTCornerButton=1
# synclient LBCornerButton=0
# synclient TapButton1=1
# synclient TapButton2=3
# synclient TapButton3=2
# synclient ClickFinger1=1
# synclient ClickFinger2=1
# synclient ClickFinger3=2
# synclient CircularScrolling=0

# Natural scrolling
# synclient VertScrollDelta=-111
# synclient HorizScrollDelta=-111
# synclient VertEdgeScroll=0
# synclient HorizEdgeScroll=0

##############################################################################

(
	xinput set-prop "${id_}" "libinput Tapping Enabled" 0 &>/dev/null
	xinput set-prop "${id_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
) || (
	xinput set-prop "${id_}" "Synaptics Scrolling Distance" "-${scrolling_distance_1_}" "-${scrolling_distance_2_}" &>/dev/null
	xinput set-prop "${id_}" "Synaptics Two-Finger Scrolling" 1, 1 &>/dev/null
)

# xinput get-button-map "SynPS/2 Synaptics TouchPad" 1 2 3 4 5 6 7 8 9 10 11 12

----

=== `config-monitors-urt` - configs external monitor for http://www.urbanterror.info[Urban Terror]

Disables laptop monitor and increases brightness, as the brightness option
doesn't work in-game.

.file::config-monitors-urt
[source,sh]
----
#!/usr/bin/env rc

laptop_mon=eDP1
main_mon=HDMI1
gamma=1.4

xrandr --output $laptop_mon --off
sleep 2
xrandr --output $main_mon --mode 1280x1024
xrandr --output $main_mon --gamma $gamma:$gamma:$gamma

----

=== `audio-toggle-mute`

.file::audio-toggle-mute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id toggle
}

----

=== `audio-unmute`

.file::audio-unmute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id 0
}

----

=== `audio-mute`

.file::audio-mute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id 1
}

----

=== `extract-audio`

Extracts from a video file, creating the same file name with appropriate
extension.

.file::extract-audio
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

report-missing-executables ffmpeg Ffmpeg || exit 1

file_="$1"

ffmpeg -i "${file_}" -vn -acodec copy \
	"$file_:r.$(ffprobe ${file_} 2>&1 | grep Audio | sed -rn 's/.*Audio: ([^ ]*).*/\1/p')"

----

=== `convert-to-mp3` - converts files to MP3

This script takes a list of files as arguments.

.file::convert-to-mp3
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables ffmpeg Ffmpeg || exit 1

for (f in $*) {
	new_name=`{echo $f | replace-extension mp3}
	ffmpeg -i $f -vn -aq 1 $"new_name
}

----

=== `convert-to-ogg-vorbis` - converts files to Ogg Vorbis

This script takes a list of files as arguments.

.file::convert-to-ogg-vorbis
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables ffmpeg Ffmpeg || exit 1

for (f in $*) {
	new_name=`{echo $f | replace-extension ogg}
	ffmpeg -i $f -vn -aq 1 $"new_name
}

----

=== `count-monitors`

.file::count-monitors
[source,sh]
----
#!/usr/bin/env bash

xrandr | grep " connected" | wc -l

----

=== `cpu-usage`

Returns the average CPU usage measured in 3 consecutive seconds, using `mpstat`.

.file::cpu-usage
[source,sh]
----
#!/usr/bin/env bash

#
# Using `mpstat', calculates average CPU usage in 3 seconds.
#

report-missing-executables mpstat Sysstat || exit 1

mpstat 3 1 | tail -1 | gawk '$12 ~ /[0-9.]+/ { print 100 - $12"%" }'

----

=== `create-ctags`

.file::create-ctags
[source,sh]
----
#!/usr/bin/env bash

#
# Creates a tags file named TAGS using ctags.
#

report-missing-executables tags "Ctags or Exuberant Ctags" || exit 1

if test -z "$1"; then
	cat <<EOF
Usage: $0 <directory> [ctags-options]*

Creates a tags file named TAGS using ctags.
EOF
	exit 2
fi

dir_name_="$1"
shift

ctags "$@" -f "${dir_name_}"/TAGS -R "${dir_name_}"/*

----

=== `create-sbcl-cmpitg-image` - dumping a customized SBCL image

Dumps a customized SBCL image and makes it work with Shelly (if installed).

.file::create-sbcl-cmpitg-image
[source,sh]
----
#!/usr/bin/env rc

if (~ $1 -h --help) {
	cat <<EOF
	exit 1
}
Dumps an SBCL image and makes it work with Shelly (if installed).

Usage: $0 [--core-path core-file] [--eval sexp]

Options:

--core-path :: Path to SBCL core file to dump to, default value:
               '/m/opt/sbcl-images/sbcl-base.core'.
--eval      :: The Sexp to evaluate before dumping, default value:
               '(load "/m/config/common-lisp/sbcl-base.lisp")'.
EOF

##############################################################################
# Sanity check
##############################################################################

report-missing-executables sbcl SBCL || exit 1

sbcl_version=`{sbcl --version | cut -d' ' -f2}

##############################################################################

fn try_set_vars {
	switch ($1) {
	case --core-path
		core_path=$2
	case --eval
		sexp=$2
	}

	if (~ $core_path '') {
		core_path=/m/opt/sbcl-images/sbcl-base.core
	}
	if (~ $sexp '') {
		sexp='(load "/m/config/common-lisp/sbcl-base.lisp")'
	}
}

try_set_vars $1 $2
try_set_vars $3 $4

if (! ~ $SHELLY_HOME '') {
	shelly_core_path=$SHELLY_HOME^'/dumped-cores/sbcl-'^$sbcl_version^'.core'
}

##############################################################################

echo Core path: $core_path
echo Sexp: $sexp
if (! ~ $shelly_core_path '') {
	echo Shelly found, path to core: $shelly_core_path
}

echo '-> Dumping core'
sbcl --noinform \
	--no-userinit \
	--eval $sexp \
	--eval '(sb-ext:save-lisp-and-die "'^$core_path^'")'

if (test -d $SHELLY_HOME/dumped-cores) {
	echo '-> Updating Shelly'
	cp -fv $core_path $shelly_core_path
	cp -fv $core_path $SHELLY_HOME/dumped-cores/sbcl.core
}

----

=== `sbcl-cmpitg`

.file::sbcl-cmpitg
[source,sh]
----
#!/usr/bin/env bash

#
# Note that --no-userinit should be after "$@", at the position of
# `user-options'.  Consult `sbcl --help' for further information.
#

sbcl --noinform --core /m/opt/sbcl-images/sbcl-base.core "$@" --no-userinit

----

=== `json-post` - makes a JSON POST

.file::json-post
[source,sh]
----
#!/usr/bin/env rc

#
# Makes a JSON POST with Curl
#

report-missing-executables curl cURL || exit 1

curl -i -H 'Content-Type: application/json' -X POST $*

----

=== `do-notify` - sends a desktop notification

.file::do-notify
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables notify-send Libnotify || exit 1

echo "$@"
exec notify-send "$@"

----

=== `do-notify-short` - sends a short desktop notification

.file::do-notify-short
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables notify-send Libnotify || exit 1

echo "$@"
exec notify-send -t 2000 "$@"

----

=== `docker-remove-orphaned-containers`

.file::docker-remove-orphaned-containers
[source,sh]
----
#!/usr/bin/env bash

docker rm $(docker ps -aq)

----

=== `docker-remove-unnamed-images`

.file::docker-remove-unnamed-images
[source,sh]
----
#!/usr/bin/env bash

docker images -a | grep "<none>" | awk '{ print $3 }' | xargs docker rmi

----

=== `drop-lines`

.file::drop-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Drops the first $1 lines.
#

n_lines=$1
n_lines=`{echo $n_lines + 1 | bc}
tail -n +$n_lines

----

=== `in_epoch2datetime` - converts the epoch from read from stdin to local date time

This script is particularly helpful when using with Emacs/Acme, e.g. called with a text selection.

.file::in_epoch2datetime
[source,sh]
----
#!/usr/bin/env sh

epoch_=$(cat)

exec date --date="@${epoch_}" -R

----

=== `en2fi` - translates from English to Finnish

.file::en2fi
[source,sh]
----
#!/usr/bin/env rc

#
# Translates from English to Finnish with Google Translate, using
# soimort/translate-shell tool.
#

report-missing-executables trans soimort/translate-shell || exit 1

TARGET_LANG=fi gtranslate $*

----

=== `fi2en` - translates from Finnish to English

.file::fi2en
[source,sh]
----
#!/usr/bin/env rc

#
# Translates from Finnish to English with Google Translate, using
# soimort/translate-shell tool.
#

report-missing-executables trans soimort/translate-shell || exit 1

TARGET_LANG=en gtranslate $*

----

=== `format-text` - formats text from stdin using Emacs's `fill-paragraph`

.file::format-text
[source,sh]
----
#!/usr/bin/env rc

#
# Formats text from stdin using Emacs's fill-paragraph.
#

input=`{cat}
sexpr=`{echo `{cat <<EOF}}

(with-temp-buffer
  (set-fill-column 78)
  (insert "$input")
  (end-of-buffer)
  (fill-region 0 (point))
  (princ (buffer-string)))
EOF

emacs --batch --eval $"sexpr $* >[2]/dev/null

----

=== `monitors-info` - retrieves information of connected monitors

.file::monitors-info
[source,sh]
----
#!/usr/bin/env rc

#
# Retrieves information of the currently connected monitors and outputs as
# followed:
# * First line: <number of monitors>
# * Second line: <monitor> <mode> <rate>
#

lines=`{xrandr \
	| grep ' connected' \
	| cut -d' ' -f1}

echo $#lines
for (output in $lines) {
	data=`{xrandr \
		| take-from $output \
		| drop-lines 1 \
		| take-lines 1 \
		| tr -d '*' \
		| tr -d '+'}
	mode=`{echo $data | cut -d' ' -f1}
	rate=`{echo $data | cut -d' ' -f2}
	echo $output $mode $rate
}

----

=== `replace-extension` - replaces file extension

.file::replace-extension
[source,sh]
----
#!/usr/bin/env rc

input=`{cat}

if (~ $1 '') {
	echo Usage: $0 '<'replacement'>' >[1=2]
	exit 1
}

rev_replacement=`{echo $1 | rev}

echo $input | rev | sed 's/^[^.]*\./'$rev_replacement'./' | rev

----

=== `uri-github2ssh` - converts Github URI to `git+ssh` style

.file::uri-github2ssh
[source,sh]
----
#!/usr/bin/env rc

#
# git@github.com:schacon/hg-git.git
# git+ssh://git@github.com/schacon/hg-git.git
#

program=`{basename $0}

if (~ $1 '' '--help') {
	cat <<USAGE
	exit 1
}
Usage: $program git@github.com:<user>/<repo>

Converts to universal git+ssh style repository URI.

E.g.

  $program git@github.com:schacon/hg-git.git
  # ⇨ git+ssh://git@github.com/schacon/hg-git.git
USAGE

uri=`{echo $1 | sed 's/:/\//g' | sed 's/git\/\/\///g'}

echo 'git+ssh://'$uri

----

=== `gitserve` - runs a Git server

.file::gitserve
[source,sh]
----
#!/usr/bin/env rc

#
# Runs a Git server.
#

program=`{basename $0}

if (~ $1 '-h' '--help') {
	cat <<USAGE
	exit 0
}
Usage:

Runs a Git server.

  $program             :: Take current directory as Git repository
  $program <git-repo>  :: Take a specific Git repository

By default, the Git server is opened on port 4242.  This could be overriden by
setting the environment variable GIT_PORT.  For example: run a Git server on
port 5454, serving content from Git repo at /m/bin:

  GIT_PORT=5454 $program /m/bin

Then, you can clone the repo with: git clone git://<host>:<port>/ <repo-name>

Note that this method is a quick way to share Git repository and it's not at
all secure.  In practice, you might want to Git server behind a reverse proxy.
USAGE

(test $#GIT_PORT -eq 0) && git_port=4242 || git_port=$GIT_PORT
(test $#1        -eq 0) && git_path='.'  || git_path=$1

exec git daemon --reuseaddr '--base-path='$git_path --export-all --verbose '--port='$git_port

----

=== `get-all-randr-outputs` - gets all RandR outputs

.file::get-all-randr-outputs
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables xrandr XRandR ag Ag awk "GNU Awk" || exit 1

xrandr | ag connected | awk '{ print $1 }'

----

=== `get-all-execs` - gets all executables, optionally prefixed with a string and history support

.file::get-all-execs
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require cmdline

if {[catch {exec report-missing-executables find "GNU Find" sort Coreutils <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

proc usage {{fd stdout}} {
    puts $fd {get-all-execs

Get all executables from the PATH environment variables, sort in ascending order, deduplicate, and return them one line per entry.}
}

proc getAccessiblePaths {} {
    set rawPaths [exec echo $::env(PATH) | sed {s/:/\n/g} | sort | uniq]
    set res {}
    foreach path $rawPaths {
        if {[file exists $path]} {
            lappend res "$path/"
        }
    }
    return $res
}

if {$::argv == "--help"} {
    usage
}
if {$::argc != 0} {
    usage stderr
    exit 1
}

set paths [getAccessiblePaths]
set execs [exec find {*}$paths -maxdepth 1 -type f,l -executable | awk {FS="/" { print $NF }} | sort -u]
catch {puts $execs}

----

=== `get-sensors-data` - gets meaningful sensors data

.file::get-sensors-data
[source,tcl]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables sensors lm-sensors acpi acpi >@ stdout 2>@ stderr}]} {
    exit 1
}

set coreTemps [exec sensors -u coretemp-isa-0000 | ag {temp.*input} | awk {{ printf("%.1f°C, ", $2) }} | sed {s/, $//} 2> /dev/null]
set coreTempsText "Cores: $coreTemps"

set fanStats [exec sensors -u thinkpad-isa-0000 | ag {fan.*input} | awk {{ printf("%.0f RPMs, ", $2) }} | sed {s/, $//} 2> /dev/null]
set fanStatsText "Fans: $fanStats"

set batStats [join [exec acpi -b | awk {{ print $4, $3 }} | sed {s/[:,]//g ; s/ Charging/+/g ; s/ Discharging/-/g ; s/ Unknown//g} 2> /dev/null]]
set batStatsText "Bats: [join $batStats {, }]"

puts "$coreTempsText | $fanStatsText | $batStatsText"

----

=== `gtranslate` - translates from stdin with Google Translate

.file::gtranslate
[source,sh]
----
#!/usr/bin/env rc

#
# Translates with Google Translate, using soimort/translate-shell tool.
#

if (! which trans >/dev/null >[2=1]) {
	echo trans command not found >[1=2]
	echo Make sure you have soimort/translate-shell installed >[1=2]
	exit 1
}

input=`{cat}
trans $* -brief $"input

----

=== `guile-source` - runs Guile with load-source-code mode

.file::guile-load-source
[source,sh]
----
#!/usr/bin/env sh

exec guile -s "$@"

----

=== `html2text`

.file::html2text
[source,sh]
----
#!/usr/bin/env bash

#
# Converts HTML to text.  HTML is read from stdin.
#

report-missing-executables lynx Lynx || exit 1

exec lynx -dump -stdin "$@"

----

=== `i3-exec-command` - executes an http://i3wm.org/[i3] command

.file::i3-exec-command
[source,sh]
----
#!/usr/bin/env bash

i3-input -f 'pango:Noto Sans 10' "$@"

----

=== `i3-move-to-workspace` - moves a window to a workspace with http://i3wm.org/[i3]

.file::i3-move-to-workspace
[source,sh]
----
#!/usr/bin/env bash

i3-input \
	-f 'pango:Noto Sans 10' \
	-F 'move workspace "%s"' \
	-P 'Move window to workspace: ' %s

----

=== `i3-rename-workspace` - renames current workspace in http://i3wm.org/[i3]

.file::i3-rename-workspace
[source,sh]
----
#!/usr/bin/env bash

i3-input \
	-f 'pango:Noto Sans 10' \
	-F 'rename workspace to "%s"' \
	-P 'Rename workspace: ' %s

----

=== `switch-window` - window switcher

Requirement: `rofi`.

.file::switch-window
[source,sh]
----
#!/usr/bin/env sh

report-missing-executables run-menu run-menu || exit 1

exec run-menu -modi window -show window

----

=== `set-only-monitors` - sets and configs only certain monitors, all others are off

.file::set-only-monitors
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx

if {[catch {exec report-missing-executables get-all-randr-outputs get-all-randr-outputs >@ stdout 2>@ stderr}]} {
    exit 1
}

proc getSetMonitors {} {
    set res {}
    set takeNow 0
    foreach cmdArg $::argv {
        # We take the argument right after the --output argument
        if {$cmdArg eq "--output"} {
            set takeNow 1
        } elseif {$takeNow} {
            lappend res $cmdArg
            set takeNow 0
        }
    }
    return $res
}

proc filterMonitors {setMonitors monitors} {
    set res {}
    foreach monitor $monitors {
        if {[lsearch $setMonitors $monitor] == -1} {
            lappend res $monitor
        }
    }
    return $res
}

set setMonitors [getSetMonitors]
set allMonitors [string trim [exec get-all-randr-outputs]]
set monitors [filterMonitors $setMonitors $allMonitors]

set cmd [list {*}$::argv]
foreach monitor $monitors {
    set cmd [list {*}$cmd "--output" $monitor "--off"]
}

puts "xrandr $cmd"
execl "xrandr" $cmd

----

=== `set-monitors-auto` - configs all monitors with default settings from XRandR

.file::set-monitors-auto
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables xrandr XRandR get-all-randr-outputs get-all-randr-outputs sed "GNU Sed" tr Coreutils || exit 1

get-all-randr-outputs | sed 's/$/ --auto/g; s/^/--output /g' | tr "\n" " " | xargs xrandr

----

=== `set-1-monitor`

.file::set-1-monitor
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx

if {[catch {exec report-missing-executables set-only-monitors set-only-monitors >@ stdout 2>@ stderr}]} {
   exit 1
}

if {[info exists ::env(MY_MAIN_MONITOR_OUTPUT)]} {
    set mainMonitor $::env(MY_MAIN_MONITOR_OUTPUT)
    set mainMode $::env(MY_MAIN_MONITOR_MODE)
} else {
    set mainMonitor [lindex $monitors 0]
    set mainMode [lindex $monitors 1]
}

execl "set-only-monitors" [list "--output" $mainMonitor "--mode" $mainMode "--primary"]

----

=== Running applications

==== Clipboard manager

.file::run-clipboard-manager
[source,sh]
----
#!/usr/bin/env sh

# pidof clipit >/dev/null 2>&1 || exec clipit
pidof greenclip >/dev/null 2>&1 || exec greenclip daemon

----

.file::display-clipboard
[source,sh]
----
#!/usr/bin/env sh

exec run-menu -modi "clipboard:greenclip print" -show clipboard -run-command '{cmd}'

----

==== Power manager

.file::run-power-manager
[source,sh]
----
#!/usr/bin/env sh

pkill xfce4-power-manager
exec xfce4-power-manager --no-daemon

----

==== Volume daemon

.file::run-volumed
[source,sh]
----
#!/usr/bin/env sh

# pkill xfce4-volumed
# exec xfce4-volumed --no-daemon

# pidof kmix >/dev/null 2>&1 || kmix

pkill pasystray ; pasystray

----

==== Input method daemon with Ibus
+
.file::run-ibus-daemon
[source,sh]
----
#!/usr/bin/env sh

exec ibus-daemon -xvr

----

==== Screenshot manager

.file::run-screenshot-manager
[source,sh]
----
#!/usr/bin/env sh

----

==== Screensaver daemon

.file::run-screensaverd
[source,sh]
----
#!/usr/bin/env sh

pidof xscreensaver >/dev/null 2>&1 || exec xscreensaver

----

==== Network manager

.file::run-network-manager
[source,sh]
----
#!/usr/bin/env sh

pkill nm-applet
exec nm-applet --sm-disable

----

==== GNOME settings daemon

.file::run-settings-daemon
[source,sh]
----
#!/usr/bin/env bash

gnome-settings-daemon -h >/dev/null 2>&1 && (
	pidof gnome-settings-daemon >/dev/null 2>&1 || gnome-settings-daemon
)
[[ -e /usr/lib/gnome-settings-daemon/gsd-xsettings ]] && (
	pidof gsd-xsettings >/dev/null 2>&1 || /usr/lib/gnome-settings-daemon/gsd-xsettings
)

----

==== Insync

.file::run-insync
[source,sh]
----
#!/usr/bin/env sh

pidof insync >/dev/null 2>&1 || exec insync start

----

==== Menu program

.file::run-menu
[source,sh]
----
#!/usr/bin/env sh

exec rofi -lines 40 \
	-width 85 \
	-i \
	-font "Go Mono 11" \
	-kb-row-select Tab \
	-kb-row-tab "" \
	-kb-accept-alt "" \
	-kb-row-left "" \
	-kb-row-right "" \
	-kb-row-up Super+c,Up,Control+p \
	-kb-row-down Super+t,Down,Control+n \
	-kb-row-left Super+h,Left,Control+b \
	-kb-row-right Super+n,Right,Control+f \
	-kb-move-front Super+d,Control+a \
	-kb-move-end Super+D,Control+e \
	-kb-move-word-back Super+g,Alt+b \
	-kb-move-word-forward Super+r,Alt+f \
	-kb-accept-custom Shift+Return \
	"$@"

----

==== Application launcher

.file::run-app-launcher
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx
package require cmdline

if {[catch {exec report-missing-executables get-all-execs get-all-execs run-menu run-menu add-to-history add-to-history <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

try {
    array set cmdArgs [::cmdline::getoptions ::argv {
        {history-file.arg "~/.local/app-runner-history" "Application history file"}
        {max-history.arg  256                           "Maximum number of entries in the history"}
        {prefix.arg       "!@ "                         "String with which each executable is prefixed"}
    } {[--history-file <app-runner-history>] [--prefix <prefix>]

Run a fuzzy searcher tool with all the executables found in the PATH environment variable and from a history file.  The result of the search is then executed based on predefined patterns as follows.

* '!@ <command> [args...]' :: Run the command in a terminal emulator
* '!! <command> [args...]' :: Run the command in a terminal emulator, pause and prompt for exiting when after the command finishes
* '<url>' :: Open the URL with 'web-browser-gui'
* '<file-path>' :: Open the file path with a text editor
* 'dir:<dir-path>'  :: Open the directory using 'dir-browser-gui'

TODO: More patterns are later supported using Plan9port's Plumber.
}]} trap {CMDLINE USAGE} {msg _o} {
    if {[llength $::argv] == 0} {
        puts $msg
        exit 0
    } else {
        puts stderr $msg
        exit 1
    }
}

proc readHistory {path} {
    if {[file exists $path]} {
        set fd [open $path r]
        set data [read $fd]
        close $fd
        return $data
    } else {
        return ""
    }
}

proc addToHistory {path maxHistory text} {
    set fd [open "| add-to-history --max-history $maxHistory $path" w]
    puts $fd $text
    close $fd
}

proc getChoice {history execs} {
    set fd [open "| run-menu -dmenu -p Text " r+]
    puts -nonewline $fd $history
    puts -nonewline $fd $execs
    flush $fd
    set res [read $fd]
    catch {close $fd}
    return [string trim $res]
}

set historyFile [file normalize $cmdArgs(history-file)]
set maxHistory $cmdArgs(max-history)
set prefix $cmdArgs(prefix)

set execs [exec get-all-execs | sed "s/^/$prefix/g"]
set history [readHistory $historyFile]
set choice [getChoice $history $execs]

if {$choice ne ""} {
    addToHistory $historyFile $maxHistory $choice
    execl dispatch-action [list $choice]
}

----

.file::run-rmacs-rocket
[source,sh]
----
#!/usr/bin/env dash

exec wihack -type toolbar rmacs --shape utils --new-frame eval '(rocket:show-command-runner-with-dedicated-frame)'
# exec rmacs --shape utils --new-frame eval '(prog1 (rocket:show-command-runner-with-dedicated-frame) (~wmii/set-frame-floating))'
# exec run-menu -modi run,drun -show run -sidebar-mode "$@"

----

==== Google Chrome

.file::run-chrome
[source,sh]
----
#!/usr/bin/env sh

# exec google-chrome --remote-debugging-port=${CHROME_REMOTE_DEBUGGING_PORT:-9222} "$@"
exec google-chrome "$@"

----

==== Whatsapp

.file::run-whatsapp
[source,sh]
----
#!/usr/bin/env sh

# exec run-chrome --app=https://web.whatsapp.com/ "$@"
exec chromium --app=https://web.whatsapp.com/ "$@"

----

==== Drop-down terminal emulator

.file::run-drop-down-term-emu
[source,sh]
----
#!/usr/bin/env sh

exec guake "$@"

----

==== Desktop calendar

.file::run-calendar
[source,sh]
----
#!/usr/bin/env sh

exec run-chrome --app=https://calendar.google.com "$@"

----

=== Desktop utilities

==== `emacsclient-commander-for-dropdown` - helper to display a commander window with Emacsclient

This executable is supposed to be used with https://github.com/noctuid/tdrop[tdrop], which, in turn, uses the executable name to perform various hacks in order to set X window properties.  Hence, its name is prefixed with `emacsclient`.

.file::emacsclient-commander-for-dropdown
[source,sh]
----
#!/usr/bin/env dash

# TODO: Help text

commander_path_=${1:-/m/scratch/commander}
emacs_socket_name_=${EMACS_SOCKET_NAME:-edit}

exec emacsclient --socket-name="${emacs_socket_name_}" --no-wait --create-frame --eval "(~smart-open-file \"${commander_path_}\")"

----

==== `toggle-dropdown-term-emu` - toggles a dropdown terminal emulator

.file::toggle-dropdown-term-emu
[source,sh]
----
#!/usr/bin/env dash

report-missing-executables tdrop tdrop || exit 1

exec tdrop --auto-detect-wm --monitor-aware konsole

----

==== `toggle-dropdown-commander` - toggles a dropdown commander window

.file::toggle-dropdown-commander
[source,sh]
----
#!/usr/bin/env dash

report-missing-executables emacsclient-commander-for-dropdown emacsclient-commander-for-dropdown || exit 1

exec tdrop --auto-detect-wm --monitor-aware emacsclient-commander-for-dropdown

----

=== `disable-x-bell`

.file::disable-x-bell
[source,sh]
----
#!/usr/bin/env sh

exec xset b off

----

=== `dispatch-action` - dispatches an action based on a string

.file::dispatch-action
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: Documentation
# TODO: Help
# TODO: Read stdin?
# TODO: report-missing-executables
# TODO: Declarative configuration?

package require Tclx

##############################################################################
# Helpers
##############################################################################

## TODO: Documentation
proc stripPrefix {text prefix} {
    return [string range $text [string length $prefix] end]
}

#
# Try opening a file.  TODO: Documentation for file pattern.
#
# \(~file-pattern? \"/tmp/aoeu\"\)                                        ⇒ t
# \(~file-pattern? \"/tmp/aoeu:10\"\)                                     ⇒ t
# \(~file-pattern? \"/tmp/aoeu:/hello world/\"\)                          ⇒ t
# \(~file-pattern? \"/tmp/non-existent\"\)                                ⇒ nil

# /tmp/aoeu -> /tmp/aoeu
# /tmp/aoeu:10
# /tmp/aoeu /hello/
# /tmp/aoeu:10 /hello/
# /tmp/aoeu +10 /hello/
proc tryOpeningFile {serverName inNewFrameP rest} {
    # Visit a file and return its buffer
    proc visitFile {serverName path} {
        return [exec rmacs --client-opts --alternate-editor=vim --name $serverName --no-wait visit $path <@ stdin 2>@ stderr]
    }

    proc gotoLine {serverName buffer number} {
        return [exec rmacs --client-opts --alternate-editor=vim --name $serverName --with-buffer $buffer eval "(goto-line $number)" <@ stdin >@ stdout 2>@ stderr]
    }

    proc gotoPattern {serverName buffer pattern} {
        return [exec rmacs --client-opts --alternate-editor=vim --name $serverName --with-buffer $buffer eval "(re-search-forward \"$pattern\")" <@ stdin >@ stdout 2>@ stderr]
    }

    set possiblePath [file normalize [lindex $rest 0]]
    if {[file exists $possiblePath]} {
        set buffer [visitFile $serverName $possiblePath]
    } else {
        set lastSepIndex [string last ":" $possiblePath]
        if {$lastSepIndex == -1} {
            return 0
        }

        set possibleRealPath [string range $possiblePath 0 $lastSepIndex-1]
        if {![file exists $possibleRealPath]} {
            return 0
        }
        set buffer [visitFile $serverName $possibleRealPath]
        set lineNumber [string range $possiblePath $lastSepIndex+1 end]
        set possiblePath $possibleRealPath
        catch {gotoLine $serverName $buffer $lineNumber}
    }

    foreach arg [lrange $rest 1 end] {
        switch -glob $arg {
            "+*" {
                set lineNumber [stripPrefix $arg {+}]
                catch {gotoLine $serverName $buffer $lineNumber}
            }
            "/*/" {
                set pattern [string range $arg 1 end-1]
                catch {gotoPattern $serverName $buffer $pattern}
            }
            default {
                puts stderr "Error: Unrecognized pattern for file path: $arg"
            }
        }
    }

    if {$inNewFrameP} {
        execl rmacs [list --client-opts --alternate-editor=vim --name $serverName --new-frame open $possiblePath]
    } else {
        exec rmacs --client-opts --alternate-editor=vim --name $serverName open $possiblePath <@ stdin >@ stdout 2>@ stderr
    }

    return 1
}

##############################################################################
# Main
##############################################################################

set text [string trim [join $::argv " "]]

if {[info exists ::env(RMACS_NAME)]} {
    set rmacsServerName $::env(RMACS_NAME)
} else {
    set rmacsServerName "edit"
}

if {$text ne ""} {
    switch -glob $text {
        "!@*" {
            set cmd [stripPrefix $text {!@}]
            execl with-env-user [list with-term-emu-detach {*}$cmd]
        }
        "!!!*" {
            set cmd [stripPrefix $text {!!!}]
            execl with-env-user [list with-term-emu {*}$cmd]
        }
        "!!*" {
            set cmd [stripPrefix $text {!!}]
            execl with-env-user [list with-term-emu with-pause {*}$cmd]
        }
        "tmux ::*" {
            set tmuxSessionName [string trim [stripPrefix $text "tmux ::"]]
            execl bring-termux-session $tmuxSessionName
        }
        "wind ::*" {
            # TODO: Check current window manager?  Or write wrapper?
            execl awesome-client [list "display_client_menu_by_actionable_title('[string trim $text]')"]
        }
        "wind-awesome ::*" {
            execl awesome-client [list "display_client_menu_by_actionable_title('[string trim $text]')"]
        }
        "wind-i3 ::*" {
            set nodeID [lindex [split [string trim $text] " "] end]
            execl exec-i3-menu [list client $nodeID]
        }
        "file ::*" {
            set path [string trim [stripPrefix $text {file ::}]]
            tryOpeningFile $rmacsServerName 1 [list $path]
        }
        default {
            if {![tryOpeningFile $rmacsServerName 0 $::argv]} {
                execl run-menu [list "-e" "Error: Unrecognized pattern: $text"]
            }
        }
    }
}

----

=== `run-menu-and-dispatch` - runs a menu program, allowing user to choose an item/input custom string, then dispatch an action based on the output

TODO: Documentation
TODO: Support history file
TODO: Make run-app-launcher depend on this

.file::run-menu-and-dispatch
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx

if {[catch {exec report-missing-executables run-menu run-menu <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

proc spitToTempFile {input} {
    file tempfile tempPath
    set fd [open $tempPath w+]
    puts -nonewline $fd $input
    close $fd
    return $tempPath
}

proc getChoice {prompt input} {
    set tempPath [spitToTempFile $input]

    set choice {}
    catch {set choice [string trim [exec run-menu -dmenu -p $prompt < $tempPath]]}
    file delete $tempPath

    return $choice
}

set prompt [lindex $::argv 0]
set input [read stdin]
set choice [getChoice $prompt $input]

if {$choice ne ""} {
    execl dispatch-action [list $choice]
}

----

=== `run-omni-switcher` - displays a window + Tmux session switcher

TODO: Help
TODO: Note on standard input

.file::run-omni-switcher
[source,sh]
----
#!/usr/bin/env zsh

report-missing-executables grep Grep run-menu-and-dispatch run-menu-and-dispatch tmux Tmux || exit 1

rmacs_server_name_=edit
if rmacs list 2>&1 | grep -e "^${rmacs_server_name_}$" >/dev/null 2>&1; then
	rmacs_server_alive_p_=1
else
	rmacs_server_alive_p_=0
fi

cat -s - \
	<(tmux list-sessions -F "#{session_name}" | sed "s/^/tmux :: /g") \
	<([[ "${rmacs_server_alive_p_}" = 1 ]] \
		&& print $(rmacs --name "${rmacs_server_name_}" eval "(~format-opened-files)") | sed 's/^"//; s/"$//; s/^/file :: /g') \
	| grep -v -e '^$' \
	| exec run-menu-and-dispatch "Switch to"

----

=== `add-to-history`

TODO: Add description

.file::add-to-history
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require cmdline
package require struct::list 1.8

try {
	array set cmdArgs [::cmdline::getoptions ::argv {
		{max-history.arg 1000 "Maximum number of items stored in the history"}
	} {[--max-history <max-history>] <history-file-path>

TODO: Documentation
}]} trap {CMDLINE USAGE} {msg _o} {
	if {[llength $::argv] == 0} {
		puts $msg
		exit 0
	} else {
		puts stderr $msg
		exit 127
	}
}

# TODO: Handle errors or missing arguments

set maxHistory $cmdArgs(max-history)
set filePath [lindex $::argv 0]

##############################################################################
# Helpers
##############################################################################

proc slurpIntoLines {path} {
	set fd [open $path r]
	set res [read $fd]
	close $fd
	return [::struct::list filterfor x [split $res "\n"] {[string trim $x] ne ""}]
}

proc readLineFromStdin {} {
	gets stdin line
	return [string trim $line]
}

proc writeLines {path lines} {
	set fd [open $path w]
	puts $fd [join $lines "\n"]
	close $fd
}

##############################################################################
# Main
##############################################################################

if {![file exists $filePath]} {
	set baseDir [file dirname $filePath]
	if {![file exists $baseDir]} {
		file mkdir $baseDir
	}

	# Create the empty file
	close [open $filePath w]

	set lines {}
} else {
	set lines [slurpIntoLines $filePath]
}

set newLine [readLineFromStdin]
set newLines [concat [list $newLine] [::struct::list filterfor x $lines {$x ne $newLine}]]
set finalLines [lrange $newLines 0 [expr {$maxHistory - 1}]]

writeLines $filePath $finalLines

puts $newLine

----

=== `join-lines`

Joins all lines using Plan 9's tr.

.file::join-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Joins all lines into one using Plan 9's tr.
#

exec tr '
' ' '
----

=== `all-dev-debs` - lists all Debian `-dev` packages installed

.file::all-dev-debs
[source,sh]
----
#!/usr/bin/env bash

dpkg-query -l '*dev' | grep "^.i" | awk '{ print $2 }' | grep "\-dev$"

----

=== `add-deb-repo` - adds a Debian-based repository

.file::add-deb-repo
[source,sh]
----
#!/usr/bin/env bash

usage() {
	cat <<EOF
add-deb-repo <sources-repo.list> <dest-repo.list>

Add a Debian-compatible sources.list file to global repository.  Should there be a command to run after adding, put it as a comment on the first line of the sources.list file.
EOF
}

if [[ "${1}" = "--help" ]]; then
	usage
	exit 0
fi

if [[ "$#" -ne 2 ]]; then
	usage >&2
	exit 1
fi

repo_path_="${1}"
dest_="/etc/apt/sources.list.d/${2}"

with-sudo symlink "${repo_path_}" "${dest_}"

if [[ "$(cat ${repo_path_})" == "#"* ]]; then
	eval $(head -1 "${repo_path_}" | cut -d'#' -f2)
fi

----

=== `local-tcp-open-p` - checks if a local TCP port is opened

.file::local-tcp-open-p
[source,sh]
----
#!/usr/bin/env bash

if (test $# -eq 0); then
	cat <<EOF
Usage: `basename $0` <port>

Determines if a local TCP port is open.  Returns 0 if it is or 1 otherwise.
EOF
fi

report-missing-executables nc Netcat || exit 1

exec nc -z 127.0.0.1 "$1"

----

=== `lockscreen`

.file::lockscreen
[source,sh]
----
#!/usr/bin/env bash

# pgrep lightdm && gdmflexiserver || gnome-screensaver-command -l
xscreensaver-command -lock \
	|| gnome-screensaver-command -l \
	|| (sh -c "dbus-send --type=method_call --dest=org.gnome.ScreenSaver /org/gnome/ScreenSaver org.gnome.ScreenSaver.Lock")

----

=== `monitor-off`

.file::monitor-off
[source,sh]
----
exec xset -display :0 dpms force off

----

=== `now-standardized`

.file::now-standardized
[source,sh]
----
#!/usr/bin/env sh

report-missing-executables date Coreutils tr Coreutils || exit 1

exec date --rfc-3339=second | tr ' ' '_'

----

=== `now-to-clipboard`

.file::now-to-clipboard
[source,sh]
----
#!/usr/bin/env bash

xterm -e 'date -R | xsel -b'

----

=== `symlink-p`

.file::symlink-p
[source,sh]
----
#!/usr/bin/env sh

#
# Determines if a file is a symbolic link
#

test -L "$@"

----

=== `filter-broken-symlinks [path1] [path2] [...]`

TODO: `--help`

.file::filter-broken-symlinks
[source,sh]
----
#!/usr/bin/env bash

#
# Filter broken symlinks from the argument list
#

for file_ in "$@" ; do
    if [ ! -e "${file_}" ]; then
        echo "${file_}"
    fi
done

----

=== `find-deep-path` - returns the full path for a file/directory that is found from `PATH`

.file::find-deep-path
[source,tclsh]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx
package require cmdline

if {[catch {exec report-missing-executables find "GNU Find" sort Coreutils <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

proc usage {{fd stdout}} {
    puts $fd {find-deep-path <command>

TODO}
}

proc findExec {cmd} {
    set rawPaths [exec echo $::env(PATH) | sed {s/:/\n/g} | sort | uniq]
    set res {}
    foreach path $rawPaths {
        if {[file exists "$path/$cmd"]} {
            return "$path/$cmd"
        }
    }
    return {}
}

if {$::argv == "--help"} {
    usage
}
if {$::argc != 1} {
    usage stderr
    exit 1
}

puts [findExec [lindex $::argv 0]]
----

=== `prompt-y-n` - prompts for a yes/no answer

Prompts a yes/no answer, exiting with code 0 for yes and non-zero for no.

.file::prompt-y-n
[source,tcl]
----
#!/usr/bin/env tclsh

proc getDefaultChoice {choice} {
	if {[string equal "" $choice]} {
		return "y"
	} else {
		return $choice
	}
}

proc getAnswer {default} {
	set answer [gets stdin]
	if {[string equal "" $answer]} {
		return $default
	} else {
		return $answer
	}
}

set prompt [lindex $argv 0]
set defaultChoice [getDefaultChoice [lindex $argv 1]]

puts -nonewline "$prompt \[y/n\] ($defaultChoice) "
flush stdout

set answer [getAnswer $defaultChoice]
if {[string equal "y" $answer]} {
	exit 0
} else {
	exit 1
}

----

=== `prompt-loading-termux-session` - loads a terminal multiplexer session interactively

.file::prompt-loading-termux-session
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

if {[catch {exec report-missing-executables run-menu cmpitg-scripts tmuxp Tmuxp >@ stdout 2>@ stderr}]} {
    exit 1
}

set tmuxSessionDir "$::env(MY_LOCAL_SETUP)/output/shell-session/config/"

if {[catch {set sessionFile [exec ls -1 $tmuxSessionDir | run-menu -dmenu -p "Session"]}]} {
    set sessionFile {}
}

if {$sessionFile ne ""} {
    execl tmuxp [list load "$tmuxSessionDir/$sessionFile"]
}

----

=== `executable-exists <exec-file>` - checks if an executable exists in `PATH`

Checks whether an executable exists in one of the `PATH`s, returning exit code 0 if it does and 127 otherwise.

.file::executable-exists
[source,sh]
----
#!/usr/bin/env sh

command -v "$@" >/dev/null 2>&1

----

=== `report-missing-executables <bin-1> <software-1> <bin-2> <software-2> ...`

Reports missing software by checking if their corresponding executables exist.  If all executables are found, exit with status 0; otherwise, exit with status 1.

Sample usage:

[source,sh]
----
report-missing-executables aria2c Aria2 wget Wget
# ⇨
# aria2c and wget not found
# Make sure you have Aria2 and Wget installed

report-missing-executables aria2c Aria2 wget Wget curl cURL
# ⇨
# aria2c, curl, and wget not found
# Make sure you have Aria2, Wget, and cURL installed

report-missing-executables aria2c Aria2 wget
# ⇨
# Invalid arguments.  Number of arguments must be even.

----

.file::report-missing-executables
[source,python]
----
#!/usr/bin/env python3

import sys
import os


def main():
	if os.environ.get('DOCTEST') == '1':
		import doctest
		doctest.testmod()
		sys.exit(0)

	if len(sys.argv) == 1:
		show_help(when_error=True)
	elif len(sys.argv) == 2 and sys.argv[1] == "--help":
		show_help()
	elif len(sys.argv) % 2 == 0:
		sys.stderr.write("Invalid arguments.  Number of arguments must be even.\n")
		sys.exit(3)
	else:
		sys.exit(
			1 if report_missing_execs(get_missing_execs(sys.argv[1:])) else 0
        )


def show_help(when_error=False):
	help_text = """
Usage:
  report-missing-executables <exec-1> <prog-1> ...
  report-missing-executables --help

Reports missing software by checking if their corresponding executables exist.
If all executables are found, exit with status 0; otherwise, exit with status
1.

E.g.

  report-missing-executables aria2c Aria2 wget Wget
    # aria2c and wget not found
    # Make sure you have Aria2 and Wget installed

  report-missing-executables aria2c Aria2 wget Wget curl cURL
    # aria2c, curl, and wget not found
    # Make sure you have Aria2, Wget, and cURL installed

  report-missing-executables aria2c Aria2 wget
    # Invalid arguments.  Number of arguments must be even.

Development note: When running with environment variable DOCTEST set to 1,
runs the Python doctest and exits.
"""
	if when_error:
		sys.stderr.write(help_text)
	else:
		sys.stdout.write(help_text)


def find_executable(name):
	"""If `name` is an executable, returns the full path to `name`; otherwise,
	returns `False`.

	>>> find_executable("ls")
	'/bin/ls'
	>>> import uuid
	>>> find_executable(str(uuid.uuid4()))
	False
	"""
	paths = os.environ.get("PATH", "").split(":")

	for path_dir in paths:
		full_path = os.path.join(path_dir, name)
		if (os.path.isfile(full_path) and os.access(full_path, os.X_OK)):
			return full_path

	return False


def found_executable(name):
	"""Determines if a name is an executable that can be called.

	>>> found_executable("ls")
	True
	>>> found_executable("python")
	True
	>>> import uuid
	>>> found_executable(str(uuid.uuid4()))
	False
	"""
	return find_executable(name) != False


def get_missing_execs(args):
	"""Gets missing executables from command line arguments.  The argument `args`
	is a list of strings `<exec-1> <program-1> <exec-2> <program-2> ...`.
	Returns the list of dictionaries with `\"executable\"` and `\"program\"`
	as keys where the corresponding executables are not found.

	>>> get_missing_execs(['ls', 'Binutils', 'python', 'Python', 'aaaSomeCrapaaa', 'Some Crap']) == [{'executable': 'aaaSomeCrapaaa', 'program': 'Some Crap'}]
	True
	"""
	return [
		dict(executable=args[i], program=args[i + 1])
		for i in range(0, len(args), 2)
		if not found_executable(args[i])
	]


def report_missing_execs(missing_list):
	"""Reports missing executables, returning `True` if there is at least one
	missing and `False` otherwise.

	"""

	def print_missing_list(pre_msg, post_msg, missing):
		if len(missing) == 1:
			output = missing[0]
		else:
			missing_butlast = missing[:-1]
			missing_last    = missing[-1]
			before_last     = ", ".join(missing_butlast)
			comma           = "," if len(missing) > 2 else ""

			output = "{}{} and {}".format(before_last, comma, missing_last)

		sys.stdout.write("{}{} {}\n".format(pre_msg, output, post_msg))

	def notify_missing(missing):
		os.system("notify-send --urgency=critical 'Missing Software' 'Missing execs: {}'".format(', '.join(missing)))

	if len(missing_list) == 0:
		return False
	else:
		print_missing_list(
			pre_msg="",
			post_msg="not found",
			missing=[x['executable'] for x in missing_list],
		)
		print_missing_list(
			pre_msg="Make sure you have ",
			post_msg="installed",
			missing=[x['program'] for x in missing_list],
		)
		notify_missing(x['executable'] for x in missing_list)
		return True


main()

----

=== `prefix` - prefixes all lines read from stdin with a string

.file::prefix
[source,sh]
----
#!/usr/bin/env rc

#
# Prefixes all lines read from stdin.
#

prefix=$1 {
	if (test $#prefix -eq 0) {
		prefix='# '
	}
	sed 's/^/'^$prefix^'/g'
}

----

=== `pretty-print-json`

.file::pretty-print-json
[source,sh]
----
#!/usr/bin/env bash

python -m json.tool "$@"

----

=== `psx` - `ps -ef | grep --color "$@"`

.file::psx
[source,sh]
----
#!/usr/bin/env bash

ps -ef | grep --color "$@"

----

=== `py2` - runs Python 2 in a http://docs.python-guide.org/en/latest/dev/virtualenvs/[virtual environment]

The name of the virtual environment could be set by setting the `VIRTUAL_ENV`
environment variable.  By default, it uses `python2-full-debian` as its name.

.file::py2
[source,sh]
----
#!/usr/bin/env bash

virtualenv_=${VIRTUAL_ENV:-python2-full-debian}

source "${WORKON_HOME}/${virtualenv_}/bin/activate"
exec python "$@"

----

=== `py3` - runs Python 3 in a http://docs.python-guide.org/en/latest/dev/virtualenvs/[virtual environment]

The name of the virtual environment could be set by setting the `VIRTUAL_ENV`
environment variable.  By default, it uses `python2-full-debian` as its name.

.file::py3
[source,sh]
----
#!/usr/bin/env bash

virtualenv_=${VIRTUAL_ENV:-python2-full-debian}

source "${WORKON_HOME}/${virtualenv_}/bin/activate"
exec python3 "$@"

----

=== `site-packages-path` - prints Python site packages path

.file::site-packages-path
[source,sh]
----
#!/usr/bin/env python

from distutils.sysconfig import get_python_lib


print(get_python_lib())

----

=== `query-password` - queries password from a password manager

The password is printed to stdout without an end-of-line character.

TODO: Help text

.file::query-password
[source,tcl]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables kwalletcli KWallet-CLI >@ stdout 2>@ stderr <@ stdin}]} {
    exit 1
}

set folder Passwords
set entry [lindex $::argv 0]

if {[catch {exec kwalletcli -f $folder -e $entry >@ stdout <@ stdin}]} {
    # Password doesn't exist
    exec kwalletcli_getpin -p "Set password" -t "Password not yet set. Please set it now" -Y "_Set" | kwalletcli -f $folder -e $entry -P
    exec kwalletcli -f $folder -e $entry >@ stdout <@ stdin
}

----

==== `query-sudo-password` - queries Sudo password with `query-password`

The password is printed to stdout without an end-of-line character.

TODO: Help text

.file::query-sudo-password
[source,tcl]
----
#!/usr/bin/env sh

report-missing-executables query-password query-password || exit 1

exec query-password Sandwich

----

=== `qrcode` - creates QR code from a string

.file::qrcode
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables \
	tempfile "tempfile utility" \
	qrencode Qrencode \
	|| exit 1

# FIXME: Not working
if (test $#* -eq 0) {
	echo No argument found
}

tmpfile=`{tempfile}^.png

qrencode -o $tmpfile -s 5 $*
do-notify-short $tmpfile' created'
display $tmpfile

----

=== `rackjure` - runs Racket with https://github.com/greghendershott/rackjure[Rackjure]

.file::rackjure
[source,sh]
----
#!/usr/bin/env bash

racket -I rackjure "$@"

----

=== `system-temperature`

.file::system-temperature
[source,sh]
----
#!/usr/bin/env bash

echo "-> Starting HDDTemp if necessary"
nc localhost 7634 &>/dev/null || (
	exec sudo hddtemp -d /dev/sda
)
echo ""

echo "-> HDD temperature"
nc localhost 7634

echo "-> CPU temperature"
sensors

----

=== `running-p` - determines if a process is running

TODO: Remove due to not being reliable

.file::running-p
[source,sh]
----
#!/usr/bin/env sh

#
# Determines if a process is running using pgrep.
#

exec pgrep "$@" &>/dev/null

----

=== `show-keyboard` - shows keyboard of modifiers, convenient when making screencast

.file::show-keyboard
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables key-mon key-mon || exit 1

key-mon --decorated --meta --theme modern "$@"

----

=== `with-sudo` - runs `sudo` with some environment variables preserved

TODO: Help text

.file::with-sudo
[source,sh]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables sudo sudo <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

package require Tclx

if {[lsearch $::argv "-"] == -1} {
    set args [list "-" {*}$::argv]
} else {
    set args $::argv
}

set sudoArgs {}
set cmd {}
set beforeDash 1
foreach arg $args {
    if {$arg eq "-i"} {
        execl sudo [list -i]
    }

    if {$arg eq "-"} {
        set beforeDash 0
        continue
    }

    if {$beforeDash == 1} {
        lappend sudoArgs $arg
    } else {
        lappend cmd $arg
    }
}

execl sudo [list {*}$sudoArgs -E env "PATH=$::env(PATH)" {*}$cmd]

----

=== `with-sudo-wallet` - runs `with-sudo`, uses a password manager to manage the Sudo password

TODO: Help text

.file::with-sudo-wallet
[source,tcl]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables sudo sudo query-sudo-password query-sudo-password <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

package require Tclx

if {[lsearch $::argv "-"] == -1} {
    set args [list "-" {*}$::argv]
} else {
    set args $::argv
}

set sudoArgs {}
set cmd {}
set beforeDash 1
foreach arg $args {
    if {$arg eq "-i"} {
        puts stderr "Cannot run interactive sudo (-i) with this command"
        exit 2
    }

    if {$arg eq "-"} {
        set beforeDash 0
        continue
    }

    if {$beforeDash == 1} {
        lappend sudoArgs $arg
    } else {
        lappend cmd $arg
    }
}

set fd [open [list | query-sudo-password Sandwich] r]
set password [read $fd]
close $fd

exec echo $password | with-sudo -k --stdin --prompt "" {*}$sudoArgs - {*}$cmd <@ stdin >@ stdout 2>@ stderr

----

=== `with-workdir <dir> <command> [args...]` - runs a command in a directory

TODO Group all shell utils in one section

TODO Help text

.file::with-workdir
[source,sh]
----
#!/usr/bin/env sh

cd "${1}"
shift
exec "$@"

----

=== `with-all-x-displays` - runs a command with all X displays

.file::with-all-x-displays
[source,tcl]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables awk Awk ag Ag >@ stdout 2>@ stderr}]} {
    exit 1
}

proc usage {{outFD stdout}} {
    puts $outFD {with-all-x-displays <command> [args...]

Run a command with all Xorg displays.}
}

if {$::argc == 0} {
    usage stderr
    exit 1
} elseif {[lindex $::argv 0] eq "--help"} {
    usage
    exit 0
}

set displays [string trim [exec w | awk {{ print $3 }} | sort | uniq | ag {^:} <@ stdin]]

foreach display $displays {
    exec env "DISPLAY=$display" {*}$::argv <@ stdin >@ stdout 2>@ stderr
}

----

=== `event/` - event-based triggers

Collection of executables that get triggered in case of an event

==== `event/watch-change <timeout> <get-state> - <trigger>...` - watches for a change (= 2 different states returned by `<get-state>`) and triggers a script

TODO: Help text and example

.file::event/watch-change
[source,tcl]
----
#!/usr/bin/env tclsh

proc slurp {cmds} {
    set fd [open [list | {*}$cmds] r]
    set data [read $fd]
    close $fd

    return $data
}

set separatorPos [lsearch $::argv "-"]
set TIMEOUT [lindex $::argv 0]
set GET_STATE_CMD [lrange $::argv 1 [expr {$separatorPos - 1}]]
set TRIGGER_CMD [lrange $::argv [expr {$separatorPos + 1}] end]

if {$TIMEOUT eq "" || $GET_STATE_CMD eq "" || $TRIGGER_CMD eq ""} {
    puts stderr "Timeout, get-state, and trigger must exist"
    exit 2
}

set state [slurp $GET_STATE_CMD]
while {1} {
    after $TIMEOUT
    set newState [slurp $GET_STATE_CMD]
    if {$newState ne $state} {
        catch {exec {*}$TRIGGER_CMD <@ stdin >@ stdout 2>@ stderr}
    }
    set state $newState
}

----

==== `event/get-monitors-states` - TODO

.file::event/get-monitors-states
[source,tcl]
----
#!/usr/bin/env tclsh

# /sys/class/drm/*/status

proc slurp {cmds} {
    set fd [open [list | {*}$cmds] r]
    set data [read $fd]
    close $fd

    return $data
}

proc getCurrentState {} {
    set paths [glob /sys/class/drm/*/status]
    set statuses [slurp [list cat {*}$paths]]
    return "{$paths} {$statuses}"
}

puts [getCurrentState]

----

=== `sudo-askpass` - runs `sudo` with a graphical askpass program, also preserving some environment variables

.file::sudo-askpass
[source,sh]
----
#!/usr/bin/env sh

if ! sudo --help >/dev/null 2>&1; then
	echo "sudo not found, please install sudo" >&2
	exit 1
fi

export SUDO_ASKPASS=${SUDO_ASKPASS:-$(which ssh-askpass)}
export DISPLAY=${DISPLAY:-":0"}

exec sudo --askpass -tt -E env "PATH=${PATH}" "$@"

----

=== `suspend-me` - suspends computer

.file::suspend-me
[source,sh]
----
#!/usr/bin/env bash

# exec sudo pm-suspend && lockscreen
exec sudo pm-suspend

----

=== `take-from` - takes all lines from stdin, starting from a pattern

.file::take-from
[source,sh]
----
#!/usr/bin/env rc

#
# Takes all lines from a pattern (representing by $1), using GNU Awk.
#

gawk 'BEGIN {
	found = 0
}
/'^$1^'/ {
	found = 1
}
{
	if (found == 1) {
		print $0
	}
}'

----

=== `take-lines` - takes the first `n` lines

.file::take-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Takes the first $1 lines using Plan 9's seq.
#

if (test $#* -eq 0) {
	n_lines=1
}
if not {
	n_lines=$1
}
sed $n_lines^q

----

=== `update-openjdk-8-font-patched` - for Debian/Ubuntu

TODO: Archive

Updates OpenJDK 8 with font rendering patch from PPA
[no1wantdthisname](https://launchpad.net/~no1wantdthisname/+archive/ubuntu/openjdk-fontfix).

.file::update-openjdk-8-font-patched
[source,sh]
----
#!/usr/bin/env rc

repo_url=http://ppa.launchpad.net/no1wantdthisname/openjdk-fontfix/ubuntu/pool/main/o/openjdk-8/
echo URL: $repo_url

latest_version=`{lynx -dump $repo_url \
	| grep '.deb' \
	| awk '{ print $2 }' \
	| sort \
	| tail -1 \
	| awk 'BEGIN { FS="/" } { print $NF }' \
	| awk 'BEGIN { FS="source_" } { print $2 }' \
	| awk 'BEGIN { FS=".deb" } { print $1 }' \
	| gnu-sed 's/_all//g'}
echo Latest version: $latest_version


current_version=`{apt-cache show openjdk-8-jdk \
	| gnu-sed -n '/installed/,+10p' \
	| grep Version \
	| awk '{ print $2 }'}
echo Current version: $current_version

if (~ $latest_version $current_version) {
	echo You have the latest version!
}
if not {
	echo Version mismatch, downloading and installing JDK 8
	debs=`{lynx -dump $repo_url \
		| grep $latest_version \
		| grep 'amd64.*\.deb$' \
		| awk '{ print $2 }'}

	temp_dir=/tmp/openjdk-deb-tmp
	echo Temp directory: $temp_dir
	mkdir -p $temp_dir
	cd $temp_dir
	for (deb in $debs) axel $deb

	echo Installing
	sudo dpkg -i *.deb
}

----

=== `wget-site`

.file::wget-site
[source,sh]
----
#!/usr/bin/env bash

wget \
	--recursive \
	--no-clobber \
	--page-requisites \
	--html-extension \
	--convert-links \
	--timestamping \
	--no-parent \
	--mirror \
	"$@"

#
# --recursive             download the entire Web site.
# --domains website.org   don't follow links outside website.org.
# --no-parent             don't follow links outside the directory tutorials/html/.
# --page-requisites       get all the elements that compose the page (images, CSS and so on).
# --html-extension        save files with the .html extension.
# --convert-links         convert links so that they work locally, off-line.
# --no-clobber            don't overwrite any existing files (used in case the download is interrupted and
#                         resumed).
# --mirror                create mirror
#

----

=== `start-xephyr` - starts a Xephyr server (for debugging window manager)

TODO: Help text

.file::start-xephyr
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables Xephyr Xephyr || exit 1

resolution_=${RESOLUTION:-800x600}

Xephyr \
	-ac \
	-br \
	-noreset \
	-screen ${resolution_} \
	:1 "$@" >/dev/null & disown

# export DISPLAY=:1.0
echo Display: $DISPLAY

----

=== `openfile-dialog` - creates a open-file dialog and prints the selected path to stdout

.file::openfile-dialog
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables zenity Zenity || exit 1

zenity --file-selection --filename `pwd` "$@" 2>/dev/null

----

=== `edit-which` - `${EDITOR} $(which <executable>)`

.file::edit-which
[source,sh]
----
#!/usr/bin/env dash

exec "${EDITOR}" $(which "${1}") "@$"

----

=== `compute-checksum-url` - computes checksum for remote file

`compute-checksum-url <checksum-tool> <uri> [curl-options] ...`

E.g.

* Compute MD5 sum for https://picsum.photos/200: `compute-checksum-url md5sum https://picsum.photos/200`

* Compute SHA1 sum for https://picsum.photos/200: `compute-checksum-url sha1sum https://picsum.photos/200`

.file::compute-checksum-url
[source,sh]
----
#!/usr/bin/env sh

checksum_tool_="${1}"
shift

report-missing-executables curl cURL "${checksum_tool_}" "${checksum_tool_}" || exit 1

exec curl --silent --location "$@" | "${checksum_tool_}" | cut -d ' ' -f 1

----

=== `safe-download` - downloads file, prompts overwriting, and compares checksums

Downloads a file, compares checksums, and prompts overwriting when necessary.  This script returns the download destination as the last line upon a successful download with exit code 0.  In case of error or checksums not matching, a non-zero exit code is returned.  This script leverages the MD5 sum, SHA1 sum, SHA256 sum from Coreutils.

E.g.

* Download to a temporary file:
+
[source,sh]
----
safe-download https://picsum.photos/200
----

* Download to `/tmp/aoeu`, prompt overwriting:
+
[source,sh]
----
safe-download --destination /tmp/aoeu https://picsum.photos/200
----

* If the current MD5 sum of `/tmp/aoeu` doesn't match `ABC`, download and overwrite it, then compute and the check the MD5 sum for the downloaded file; otherwise, skip the download:
+
[source,sh]
----
safe-download --destination /tmp/aoeu --md5sum ABC https://picsum.photos/200
----

* Same as the previous example except that the SHA1 sum is taken into account along with the MD5 sum:
+
[source,sh]
----
safe-download --destination /tmp/aoeu --md5sum ABC --sha1sum DEF https://picsum.photos/200
----

.file::safe-download
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8.2
package require fileutil

try {
	array set args [::cmdline::getoptions ::argv {
		{destination.arg "" "(optional) The download destination"}
		{md5sum.arg      "" "(optional) The MD5 checksum"}
		{sha1sum.arg     "" "(optional) The SHA1 checksum"}
		{sha256sum.arg   "" "(optional) The SHA256 checksum"}
		{sha512sum.arg   "" "(optional) The SHA512 checksum"}
	} {[options] <uri>

Download a file, compare checksum if necessary, and return the path to the downloaded file.  If the download destination is not specified, a temporary path is returned.
}]
} trap {CMDLINE USAGE} {msg _o} {
	puts $msg
	exit 0
}

if {[catch {exec report-missing-executables aria2c Aria2c >@ stdout 2>@ stderr}]} {
	exit 1
}

proc getDestination {dest} {
	if {$dest eq ""} {
		set path [::fileutil::tempfile]
		file delete -- $path
		return $path
	} else {
		return $dest
	}
}

proc getURI {uri} {
	if {$uri eq ""} {
		puts stderr "URI must be provided"
		exit 1
	} else {
		return $uri
	}
}

proc checksumsMatched {path checksumDict} {
	proc checksumMatched {path type checksum} {
		set checksum [string toupper $checksum]
		if {$checksum eq ""} {
			return 1
		} else {
			switch $type {
				md5 {
					return [expr {$checksum eq [string toupper [exec md5sum $path | cut -f1 -d " "]]}]
				}
				sha1 {
					return [expr {$checksum eq [string toupper [exec sha1sum $path | cut -f1 -d " "]]}]
				}
				sha256 {
					return [expr {$checksum eq [string toupper [exec sha256sum $path | cut -f1 -d " "]]}]
				}
				sha512 {
					return [expr {$checksum eq [string toupper [exec sha512sum $path | cut -f1 -d " "]]}]
				}
				default {
					return 1
				}
			}
		}
	}
	return [expr {[checksumMatched $path md5 [dict get $checksumDict md5sum]]
				  && [checksumMatched $path sha1 [dict get $checksumDict sha1sum]]
				  && [checksumMatched $path sha256 [dict get $checksumDict sha256sum]]
				  && [checksumMatched $path sha512 [dict get $checksumDict sha512sum]]}]
}

proc downloadFile {destDir destFile uri} {
	return [exec aria2c --dir $destDir --out $destFile $uri >@ stdout 2>@ stderr]
}

set dest [getDestination $args(destination)]
set destDir [file dirname $dest]
set destFile [file tail $dest]
set uri [getURI [lindex $::argv 0]]
set checksumDict [dict create md5sum $args(md5sum) sha1sum $args(sha1sum) sha256sum $args(sha256sum) sha512sum $args(sha512sum)]

if {[lindex [array get ::env VERBOSE] 1] == 1} {
	# Be verbose
	parray args
	puts "Destination: $dest"
	puts "URI: $uri"
}

if {[file exists $dest]} {
	if {[dict values $checksumDict] == {{} {} {}}} {
		try {
			exec prompt-y-n "$dest exists, would you like continue and overwrite it?" y <@ stdin >@ stdout 2>@ stderr
			file delete -- $dest
			downloadFile $destDir $destFile $uri
		} trap CHILDSTATUS {_msg _options} {}
	} elseif {![checksumsMatched $dest $checksumDict]} {
		file delete -- $dest
		downloadFile $destDir $destFile $uri
	}
} else {
	downloadFile $destDir $destFile $uri
}

if {![checksumsMatched $dest $checksumDict]} {
	exit 1
} else {
	puts $dest
}

# Local Variables:
# indent-tabs-mode: t
# End:

----

=== `random-string` - generates a random alphanumeric string

.file::random-string
[source,sh]
----
#!/usr/bin/env bash

length_=${1:-32}

cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${length_} | head -n 1

----

=== `daemontools`-compatible utils

==== `sv-create-user-supervisor` - creates a supervision daemon for the current user

.file::sv-create-user-supervisor
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

## include::tcl-helpers

##############################################################################
# Helpers
##############################################################################

proc execCmd {args} {
     return [exec {*}$args <@ stdin >@ stdout 2>@ stderr]
}

proc getRunsvdirLogContent {servicePath} {
    return [format {#!/usr/bin/env sh

mkdir -p %s/log/main
exec svlogd -ttt %s/log/main
} $servicePath $servicePath]
}

proc getRunsvdirContent {user userDaemonEnableDir} {
    return [format {#!/usr/bin/env sh

exec 2>&1
exec sudo -H -E -u %s runsvdir -P %s
} $user $userDaemonEnableDir]
}

proc createExecutableAsRoot {path content} {
    if {[file exists $path]} {
        puts -nonewline "$path exists, remove it? \[y/N\] "
        flush stdout
        set answer [string tolower [string trim [gets stdin]]]
        if {$answer eq "y"} {
            execCmd with-sudo rm -rvI $path
        } else {
            exit 0
        }
    }

    file tempfile tempFile /tmp/tempfile

    set f [open $tempFile w]
    puts $f $content
    close $f

    execCmd with-sudo mv $tempFile $path
    execCmd with-sudo chmod +x $path
}

##############################################################################
# Main
##############################################################################

if {$argc == 0} {
    set user $::env(USER)
} else {
    set user [lindex $argv 0]
}

if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonDir $::env(MY_DAEMON_DIR)
} else {
    set userDaemonDir /home/$user/daemon
}

set userDaemonEnableDir $userDaemonDir/enabled
set userDaemonAvailableDir $userDaemonDir/available
set serviceName runsvdir-$user
set servicePath /etc/sv/$serviceName

puts "User: $user"
puts "Supervisor service path: $servicePath"
puts "User service path (available): $userDaemonAvailableDir"
puts "User service path (enabled): $userDaemonEnableDir"
puts ""

execCmd with-sudo mkdir -p $servicePath/log/main
file mkdir $userDaemonAvailableDir
file mkdir $userDaemonEnableDir

createExecutableAsRoot $servicePath/run     [getRunsvdirContent $user $userDaemonEnableDir]
createExecutableAsRoot $servicePath/log/run [getRunsvdirLogContent $servicePath]

exec with-sudo symlink $servicePath /etc/service/$serviceName

puts "Done, please restart the Runit service"

----

==== `sv-enable` - enables a daemon

.file::sv-enable
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text

set serviceName [lindex $argv 0]
if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonPath $::env(MY_DAEMON_DIR)
} else {
    set userDaemonPath [file normalize ~/daemon]
}

set servicePath [glob -nocomplain $userDaemonPath/available/$serviceName]
set enablePath $userDaemonPath/enabled/$serviceName

if {$servicePath eq ""} {
    puts stderr "Error: $servicePath doesn't exist"
    exit 1
}

exec symlink $servicePath $enablePath <@ stdin >@ stdout 2>@ stderr

----

==== `sv-disable` - disables a daemon

.file::sv-disable
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text

set serviceName [lindex $argv 0]
if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonPath $::env(MY_DAEMON_DIR)
} else {
    set userDaemonPath [file normalize ~/daemon]
}

set enablePath [glob -nocomplain $userDaemonPath/enabled/$serviceName]

if {$enablePath ne ""} {
    file delete $enablePath
}

----

==== `sv-list` - lists current daemons

.file::sv-list
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

if {$::env(USER) eq "root"} {
    set supervisedPath /etc/service
} else {
    if {[info exists ::env(MY_DAEMON_DIR)]} {
        set supervisedPath $::env(MY_DAEMON_DIR)/enabled
    } else {
        set supervisedPath [file normalize ~/daemon/enabled]
    }
}

foreach dir [glob -nocomplain $supervisedPath/*] {
    puts [file tail $dir]
}

----

==== `sv-tail-log` - tails a log file for a daemon

.file::sv-tail-log
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

set serviceName [lindex $::argv 0]
set logFile [lindex $::argv 1]

if {$::env(USER) eq "root"} {
    set supervisedPath /etc/service
} else {
    if {[info exists ::env(MY_DAEMON_DIR)]} {
        set supervisedPath $::env(MY_DAEMON_DIR)/enabled
    } else {
        set supervisedPath [file normalize ~/daemon/enabled]
    }
}

execl tail [list "-f" $supervisedPath/$serviceName/log/main/$logFile]

----

== High-level "fingertip" executables

=== `enrich-path` - enriches `PATH`, then executes a command

TODO: Help text

TODO: Note on the rationale of this executable - To modularize scripting/shelling

.file::enrich-path
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: Check argv length

# TODO: Help text

# TODO: Order of args - which overrides which

##############################################################################
# Helper
##############################################################################

proc addSuffixToPaths {paths suffix} {
    set res {}
    foreach e $paths {
        set fullPath "$e$suffix" 
        if {[file exists $fullPath]} {
            lappend res $fullPath
        }
    }
    return [list {*}$res {*}$paths]
}

proc processAddedPath {addedPath} {
    set paths [split $::env(PATH) ":"]
    set newPaths [addSuffixToPaths $paths "/$addedPath"]
    set ::env(PATH) [join $newPaths ":"]
}

##############################################################################
# Main
##############################################################################

# Mark the end of the list of envs if needed
if {[lsearch $::argv "-"] == -1} {
    set addedPaths [lrange $::argv 0 0]
    set args [lrange $::argv 1 end]
} else {
    set index [lsearch $::argv "-"]
    set addedPaths [lrange $::argv 0 [expr {$index - 1}]]
    set args [lrange $::argv [expr {$index + 1}] end]
}

foreach addedPath $addedPaths {
    processAddedPath $addedPath
}

if {[lindex $args 0] ne ""} {
    execl [lindex $args 0] [lrange $args 1 end]
}

----

=== `fastls` - a bit faster `ls`

Traditionally, `ls` `stat`s corresponding path(s).  This doesn't work so well with remote mount with high latency.  `fastls` attempts to mitigate this issue.

.file::fastls
[source,sh]
----
#!/usr/bin/env sh

report-missing-executables find Find || exit 1

exec find "$@" -maxdepth 1

----

== Legacy/Unused executables

=== `wenv` - shorthand to execute a command in an environment or in a subdirectory in `PATH`

.file::wenv
[source,sh]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: Check argv length

# TODO: Help text

set envName [lindex $::argv 0]
set args [lrange $::argv 1 end]

proc addSuffixToPaths {paths suffix} {
    set res {}
    foreach e $paths {
        lappend res "$e$suffix"
    }
    return [list {*}$res {*}$paths]
}

switch $envName {
    pure {
        execl with-env-pure $args
    }
    user -
    u {
        execl with-env-user $args
    }
    python -
    conda -
    py {
        execl with-conda $args
    }
    default {
        set paths [split $::env(PATH) ":"]
        set newPaths [addSuffixToPaths $paths "/$envName"]
        set ::env(PATH) [join $newPaths ":"]
        execl [lindex $args 0] [lrange $args 1 end]
    }
}

----

=== `i3-switch-window` - window switcher for http://i3wm.org/[i3]

Requirement: `dmenu`.

[source,python]
----
#!/usr/bin/env python3

#
# Copyright (C) 2015-2016  Ha-Duong Nguyen <cmpitg@gmail.com>
#
# i3-switch-window is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# i3-switch-window is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# i3-switch-window.  If not, see <http://www.gnu.org/licenses/>.
#

#
# Requirements:
#   Python 3
#   dmenu with Xft patch
#

import json
import subprocess
import sys


# dmenu_options      = '-b -i -l 40 -fn "Noto Sans-10" -nf "#ffa077" -nb "#202020"'
dmenu_options      = '-p Window -i -l 40 -fn "Noto Sans-10" -nf "#ffa077" -nb "#202020"'
title_format       = "{} — {}"
cmd_get_tree       = "i3-msg -t get_tree"
cmd_switch_window  = "i3-msg '[con_id={}] focus'"


def main():
	fail_if_dmenu_not_found()

	global dmenu_options
	global cmd_get_tree
	global cmd_switch_window

	tree = json.loads(subprocess.check_output(
		cmd_get_tree,
		stderr=subprocess.STDOUT,
		shell=True
	).decode('utf-8'))

	windows       = get_all_windows(tree)
	lookup_table  = build_lookup_table(windows)
	chosen        = dmenu(itemize(windows), dmenu_options)

	switch_to_window(
		chosen=chosen,
		table=lookup_table,
		cmd=cmd_switch_window
	)


def fail_if_dmenu_not_found():
	"""Check if dmenu exists and exit if it doesn't."""
	if subprocess.call("which dmenu", shell=True) != 0:
		sys.stdout.write("dmenu not found\n")
		sys.stdout.write("Make sure you have dmenu installed\n")
		sys.exit(1)


def switch_to_window(chosen, table, cmd):
	"""Switch to the chosen window."""
	window_id = table.get(chosen, -1)
	if window_id != -1:
		subprocess.check_call(cmd.format(window_id), shell=True)


def window_as_string(with_id=False):
	global title_format

	def helper(window):
		title = title_format.format(window['class'], window['title'])
		if with_id:
			return title, window['id']
		else:
			return title

	return helper


def build_lookup_table(windows):
	stringifized = map(window_as_string(with_id=True), windows)
	return dict(stringifized)


def itemize(windows):
	"""Itemize windows list for dmenu."""
	return "\n".join(map(window_as_string(with_id=False), windows))


def get_all_windows(tree):
	"""Extracts all windows from i3 tree."""
	# Add current window
	if is_window(tree):
		result = [standardize_window(tree)]
	else:
		result = []

	# Add child windows
	children = []
	for window in tree['nodes']:
		children += get_all_windows(window)

	return result + children


def is_window(tree):
	"""Determines if a tree is a window."""
	return tree['window'] \
		and tree['window_properties']['class'].lower().find('panel') == -1


def standardize_window(window):
	"""Extracts necessary information for a window."""
	return {
		'id':       window['id'],
		'title':    window['window_properties']['title'],
		'class':    window['window_properties']['class'],
		'instance': window['window_properties']['instance']
	}


def dmenu(items, dmenu_options):
	"""Calls dmenu to display and menu for window switching."""
	cmd = subprocess.Popen(
		"dmenu {}".format(dmenu_options),
		shell=True,
		stdin=subprocess.PIPE,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE
	)
	stdout, _ = cmd.communicate(items.encode('utf-8'))
	return stdout.decode('utf-8').strip('\n')


if __name__ == '__main__':
	main()

----

== License

This project is released under the terms of the FreeBSD license.  See `LICENSE` for further information.
