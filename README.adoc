= `bin`
:toc: auto
:toclevels: 4
:numbered:
:experimental: true
:icons: font
:source-highlighter: pygments
:pygments-css: class

:toc:

Script collection.  Many of them are written in http://doc.cat-v.org/plan_9/4th_edition/papers/rc[Rc shell], for Bourne-or-Bash-compatible shell suffers from many design flaws, making it difficult to maintain.

This document is written in literate programming style.  To generate scripts and documentation, you need latest stable version of https://github.com/cmpitg/ulquikit[Ulquikit].  You could also clone the repo and start using it yourself.  All executables are in `bin/`.

TODO: Script to display a persistent notification for current desktop

TODO: Explain how commands are built the way they are built below:
* When to pass as argumment?  When to pass into stdin?
* When to output as text?  Human-readable?
* What about exit code?

TODO: Help text for all commands

TODO: fzf integration; use cases: convert-to-* + fzf

TODO: GNU parallel integration

TODO: Write about shell design flaws

== Requirements

For everything to function correctly, you need:

* https://github.com/9fans/plan9port[Plan 9 from User Space] (Plan9port)
* GNU Emacs 26+
* Python 3
* https://www.google.com/get/noto/[Noto Font]

Some scripts depend on others.  It's best to fulfill the requirements for all
of them.

== Notes

My environment is unusual:

* `${HOME}/Data` is either a symlink or a mount point, pointing to all
  configuration and data belonging to the tools I use.
+
If you have a separated `${HOME}`, you just need to create the `Data`
directory.
+
The main reasons why I don't use separated partition for `${HOME}` is because:
1) `${HOME}` itself is extremely inconsistent and cluttered (`.config`,
`.local`, dot files, capticalized names vs. lower-case names, etc.); and 2) I
use serveral distros, where each piece of software is slightly different in
versions, thus different in configuration.
+
In my main system, `/home/cmpitg/Data` is a symlink to `/mnt/home/cmpitg`,
whereas `/mnt/home` is a mount point.

* `${HOME}/Data/Mount-Points` contains a collection of shortcuts to various
  directories, and `/m` is its symlink into `/`.
+
I like to separate the original directories from their shortcuts and to make
things globally visible.  Some might argue that this is a serious security
flaw.  I disagree.  Private things should be kept away.  Your `.ssh` should
never stay in `/m`.

* `/m/${USER}` is a symlink back to `${HOME}/Data`, so all symlinks in `/m`
  can utilize `/m/${USER}` itself.
+
Symlinks are very useful if used appropriately (examples include the
https://nixos.org/nix/[Nix package manager]).  For me, using `/m/src` is much
more effective and unified than `~/src` for `~` depends on what your current
user is.  I could also re-symlink `/m/src` whenever I with minimal effects on
other parts of the system.
+
[source]
----
✗ l /m
lrwxrwxrwx 1 root root 30 Nov 28 20:24 /m -> /home/cmpitg/Data/Mount-Points/

✗ l /m/
total 12K
drwxr-xr-x  4 cmpitg cmpitg 4.0K Nov 28 22:04 ./
drwxr-xr-x 29 cmpitg cmpitg 4.0K Dec  1 23:44 ../
dr-xr-xr-x  1 cmpitg cmpitg    0 Jan  1  1970 9p-fonts/
drwxr-xr-x  2 cmpitg cmpitg 4.0K Nov 23 22:23 acme/
lrwxrwxrwx  1 cmpitg cmpitg   13 Nov 28 22:01 bin -> /m/cmpitg/Bin/
lrwxrwxrwx  1 cmpitg cmpitg   17 Nov 28 20:22 cmpitg -> /home/cmpitg/Data/
lrwxrwxrwx  1 cmpitg cmpitg   16 Feb 15  2015 config -> /m/cmpitg/Config/
lrwxrwxrwx  1 cmpitg cmpitg   13 Nov 28 22:02 opt -> /m/cmpitg/Opt/
lrwxrwxrwx  1 cmpitg cmpitg   17 Aug  3  2014 scratch -> /m/cmpitg/Scratch/
lrwxrwxrwx  1 cmpitg cmpitg   18 Nov 28 22:04 src -> /m/cmpitg/Src/
lrwxrwxrwx  1 cmpitg cmpitg   15 Feb 15  2015 talks -> /m/cmpitg/Talks/
lrwxrwxrwx  1 cmpitg cmpitg   17 Aug  3  2014 toolbox -> /m/cmpitg/Toolbox/
lrwxrwxrwx  1 cmpitg cmpitg   22 Aug  3  2014 virtenvs -> /m/cmpitg/Virtual-Envs/
lrwxrwxrwx  1 cmpitg cmpitg   18 Nov 28 20:35 www -> /m/cmpitg/WWW/
----
+
Most directories should speak for themselves.  Exceptions include:
+
** `/m/9p-fonts`: mounted by Plan9port's `fontsrv` to serve fonts, and
** `/m/acme`: file system interface of Acme.

== Installation

For installation of Plan9port, please refer to
https://github.com/9fans/plan9port[its original documentation].  Below is one
example session for Debian-based distros:

[source,sh]
----
sudo apt install -y build-essential libfreetype6-dev libx11-dev libx11-xcb-dev git libxt-dev xorg-dev xserver-xorg-dev
cd /path/to/src/
git clone https://github.com/9fans/plan9port.git
cd plan9port
./INSTALL

# No need to add plan9port/bin to PATH as the `9` script below is used to
# invoke Plan 9 applications
----

For Emacs, Python, and Noto Font, please consult your distro's documentation.
Example with Debian:

[source,sh]
----
sudo apt install python3 fonts-noto emacs25
----

'''''

== Contents

=== `bash-pure` - runs Bash in a clean environment

.file::bash-pure
[source,sh]
----
#!/usr/bin/env sh

# exec env --ignore-environment - HOME="${HOME}" USER="${USER}" DISPLAY="${DISPLAY}" bash --login --noprofile --norc "$@"
exec bash --noprofile --norc "$@"

----

=== `with-env-pure` - runs a command under `bash-pure`

.file::with-env-pure
[source,sh]
----
#!/usr/bin/env bash-pure

exec "$@"

----

=== `bash-user` - runs Bash with the current user's environment

.file::bash-user
[source,sh]
----
#!/usr/bin/env bash-pure

if [ -f "~/.env" ]; then
	. ~/.env
fi
if [ -f "~/.env-prog" ]; then
	. ~/.env-prog
fi

exec bash "$@"

----

=== `with-env-user` - runs a command under `bash-user`

.file::with-env-user
[source,sh]
----
#!/usr/bin/env bash-user

exec "$@"

----

=== `bash-guix` - runs Bash with a pure Guix environment

.file::bash-guix
[source,sh]
----
#!/usr/bin/env bash-user

set +x

export GUIX_LOCPATH="${HOME}/.guix-profile/lib/locale"
export GUIX_LD_WRAPPER_ALLOW_IMPURITIES=n

export PATH="${HOME}/.config/guix/current/bin:${PATH}"
export INFOPATH="${HOME}/.config/guix/current/share/info:${INFOPATH}"
export GUIX_PROFILE="${HOME}/.guix-profile"
[[ -e "${HOME}/.config/guix/current/etc/profile" ]] && . "${HOME}/.config/guix/current/etc/profile"
[[ -e "${HOME}/.guix-profile/etc/profile" ]] && . "${HOME}/.guix-profile/etc/profile"

XDG_DATA_DIRS="${XDG_DATA_DIRS:-${HOME}/.local/share}"
XDG_DATA_DIRS="${XDG_DATA_DIRS}:/usr/share:/usr/local/share:${HOME}/.local/share"
export XDG_DATA_DIRS

exec bash "$@"

----

=== `with-env-guix` - runs a command under `bash-guix`

.file::with-env-guix
[source,sh]
----
#!/usr/bin/env bash-guix

exec "$@"

----

=== `with-conda` - runs a command with Python from https://docs.conda.io/en/latest/[Conda] environment

.file::with-conda
[source,sh]
----
#!/usr/bin/env bash

CONDA_PATH="${CONDA_PATH:-/m/opt/miniconda3}"
export PATH="${CONDA_PATH}/bin:${PATH}"

if ! report-missing-executables conda Conda; then
	exit 1
fi

eval "$(${CONDA_PATH}/bin/conda shell.bash hook)"

exec "$@"

----

=== `with-chruby` - runs a command in a https://github.com/postmodern/chruby[`chruby`] environment

.file::with-chruby
[source,sh]
----
#!/usr/bin/env bash

if [[ -z "${RUBY_CHRUBY_VERSION}" ]]; then
	echo "RUBY_CHRUBY_VERSION not defined, aborting..." >&2
	exit 3
fi

# Only run with Bash or Zsh
if [[ -n "${BASH}" || -n "${ZSH_NAME}" ]]; then
	. /usr/local/share/chruby/chruby.sh
	. /usr/local/share/chruby/auto.sh
	export -f chruby
	chruby ${RUBY_CHRUBY_VERSION}
fi

"$@"

----

=== `with-graalvm` - runs a command with Java from https://www.graalvm.org/[GraalVM]

.file::with-graalvm
[source,sh]
----
#!/usr/bin/env bash

export JAVA_HOME=/m/opt/graalvm
export PATH="${JAVA_HOME}/bin:${PATH}"

exec "$@"

----

=== `with-pause` - runs a command, then pause and wait for user to input Enter to exit

.file::with-pause
[source,sh]
----
#!/usr/bin/env bash

"$@"
read -p "Press Enter to exit..."

----

=== `9` - sets up the environment for Plan9port applications

* Starts and mounts 9p font server to `/m/9p-fonts`
* Creates temporary directory: `/tmp/9-${USER}`
* And executes a command in a Plan9port environment in `${PLAN9}/bin`.  If `PLAN9` variable is not set, it is set to `/m/opt/plan9port` by default.

.file::9
[source,sh]
----
#!/usr/bin/env bash

##
## Sets up the environment for Plan9port applications:
## * Starts plumber and font server
## * Runs the corresponding program
##

export TEMP9=/tmp/9-${USER}
export PLAN9=/m/opt/plan9port
export PATH=${PLAN9}/bin:${PATH}

export SHELL=rc
export TERM=9term
export font='/m/9p-fonts/GoMono/11a/font'

mkdir -p ${TEMP9}
mkdir -p /m/9p-fonts

running-p plumber || plumber
running-p fontsrv || \
	nohup fontsrv \
		-m /m/9p-fonts \
		>${TEMP9}/fontsrv.out \
		2>${TEMP9}/fontsrv.err &

exec ${PLAN9}/bin/9 "$@"

----

=== `9-term` - runs Plan9port terminal emulator within a 9 environment

.file::9-term
[source,sh]
----
#!/usr/bin/env sh

#
# Starts 9term within an Rc environment.
#

exec 9 9term $*

----
=== `rc` - runs RC shell with Plan 9 Port environment

.file::rc
[source,sh]
----
#!/usr/bin/env bash

exec 9 rc "$@"

----

=== `acme` - runs Plan9port Acme with `9`

Font can be chosen by setting the `font` environment variable.  By default, it
is set to `/m/9p-fonts/Go Mono/11a/font`.

.file::acme
[source,sh]
----
#!/usr/bin/env rc

#
# Starts Acme with font specified by variable `font'.  By default, use Droid
# Sans Mono.
#

if (~ $font '') {
	font='/m/9p-fonts/GoMono/11a/font'
}

mkdir -p /m/acme

acme -a \
	-m /m/acme \
	-f $font $* $toolbox

----

=== `term-emu` - wrapper for terminal emulator

.file::term-emu
[source,sh]
----
#!/usr/bin/env sh

# Terminator has some memory leaks, throws GTK error messages to the console
# GNOME terminal doesn't handle mouse scrolling well
# XFCE4 terminal crashes randomly (under load?)

term_emu_="${MY_TERM_EMU:-konsole}"

exec "${term_emu_}" "$@"

----

=== `with-term-emu` - runs a command in a termimal emulator

.file::with-term-emu
[source,sh]
----
#!/usr/bin/env sh

# exec term-emu -x with-termux "/usr/bin/env with-env-user $*"
exec term-emu -e with-termux "/usr/bin/env with-env-user $*"

----

=== `with-term-emu-detach` - runs and detachs a command in a termimal emulator

.file::with-term-emu-detach
[source,sh]
----
#!/usr/bin/env sh

# exec term-emu -x with-termux "/usr/bin/env with-env-user $*" \; detach
exec term-emu -e with-termux "/usr/bin/env with-env-user $*" \; detach

----

=== `with-termux` - runs a command with a terminal multiplexer

.file::with-termux
[source,sh]
----
#!/usr/bin/env sh

exec tmux new-session "$@"

----

=== `note-taker` - runs a note taker

.file::note-taker
[source,sh]
----
#!/usr/bin/env sh

exec chromium --app=https://notion.so "$@"

----

=== `newline`

.file::newline
[source,sh]
----
#!/usr/bin/env sh

printf "\n"
----

=== `gnu-awk` - specifically calls the GNU implementation of Awk

.file::gnu-awk
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables gawk "GNU Awk" || exit 1

exec gawk "$@"

----

=== `gnu-sed` - specifically calls the GNU implementation of sed

.file::gnu-sed
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables sed "GNU sed" || exit 1

if (/bin/sed --version 2>/dev/null | head -1 | grep sed &>/dev/null); then
	exec /bin/sed "$@"
elif (sed --version 2>/dev/null | head -1 | grep sed &>/dev/null); then
	exec sed "$@"
else
	echo You don\'t have GNU sed installed. >&2
	exit 1
fi

----

=== `gnu-tar` - specifically calls the GNU implementation of Tar

.file::gnu-tar
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tar "GNU tar" || exit 1

if (/bin/tar --version 2>/dev/null | head -1 | grep tar &>/dev/null); then
	exec /bin/tar "$@"
elif (tar --version 2>/dev/null | head -1 | grep tar &>/dev/null); then
	exec tar "$@"
else
	echo You don\'t have GNU tar installed. >&2
	exit 1
fi

----

=== `gnu-tr` - attempts to call the GNU implementation of tr

.file::gnu-tr
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tar "GNU tr" || exit 1

if (/bin/tr --version 2>/dev/null | head -1 | grep tr &>/dev/null); then
	exec /bin/tr "$@"
elif (/usr/bin/tr --version 2>/dev/null | head -1 | grep tr &>/dev/null); then
	exec /usr/bin/tr "$@"
else
	echo You don\'t have GNU tr installed. >&2
	exit 1
fi

----

=== `upcase` - upcases a string (read from stdin)

.file::upcase
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tr "GNU tr" || exit 1

exec gnu-tr '[:lower:]' '[:upper:]'

----

=== `downcase` - downcases a string (read from stdin)

.file::downcase
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables tr "GNU tr" || exit 1

exec gnu-tr '[:upper:]' '[:lower:]'

----

=== `view-man` - views a Man page in a GUI pager (Rmacs)

.file::view-man
[source,sh]
----
#!/usr/bin/env tclsh

set page [lindex $::argv 0]

exec rmacs --new-frame eval "(let ((frame (selected-frame)))
  (man \"$page\")
  (delete-frame frame)
  (setq-local local/delete-frame-on-close t))" <@ stdin >@ stdout 2>@ stderr

----

=== `rmacs-pager` - uses Rmacs GUI as a poor man's pager

TODO: Description and potential improvement

.file::rmacs-pager
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require fileutil 1.15

set tempPath [::fileutil::tempfile]
set tempBufferName [exec random-string]
exec cat > $tempPath <@ stdin
exec rmacs --new-frame eval "(with-current-buffer (get-buffer-create \"$tempBufferName\")
  (insert-file \"$tempPath\")
  (delete-file \"$tempPath\" nil)
  (setq-local local/delete-frame-on-close (selected-frame))
  (Man-cleanup-manpage)
  ;; (Man-fontify-manpage)
  (switch-to-buffer (current-buffer)))" >@ stdout 2>@ stderr

----

=== `rmacs-tee` - tee's to an Rmacs buffer

TODO: Description

.file::rmacs-tee
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require fileutil 1.15

set serverName [lindex $::argv 0]
set bufferName [lindex $::argv 1]

set bufferSize 4096
set tempPath [::fileutil::tempfile]

proc spit {path content} {
    set fd [open $path w]
    puts -nonewline $fd $content
    close $fd
}

while {![eof stdin]} {
    set input [read stdin $bufferSize]
    puts -nonewline $input
    spit $tempPath $input
    exec rmacs --name $serverName eval "(with-current-buffer (get-buffer-create \"$bufferName\")
  (save-excursion
    (goto-char (point-max))
    (insert-file \"$tempPath\")))
  " 2>@ stderr
}

file delete $tempPath

----

=== `cat-which <executable>` - `cat $(which executable-1 [executable-2] [...])`

.file::cat-which
[source,sh]
----
#!/usr/bin/env bash

#
# Finds full path executables and displays the content.
#


for exec_ in "$@"; do
	if $(which "${exec_}" &>/dev/null); then
		cat $(which "${exec_}")
	else
		echo "${exec_} not found" >&2
	fi
done

----

=== `check-broken-symlinks [path1] [path2] [...]`

.file::check-broken-symlinks
[source,sh]
----
#!/usr/bin/env bash

#
# Checks for broken symlinks.
#

for file_ in "$@" ; do
	if [ -L "${file_}" ]; then
		if readlink -q "${file_}" >/dev/null ; then
			echo "Good link: ${file_}"
		else
			echo "${file_}: bad link" >/dev/stderr
		fi
	else
		echo "${file_} is not a symlink"
	fi
done

----

=== `buildapp-cmpitg` - builds Common Lisp standalone executable

With https://github.com/xach[@xach's]
http://www.xach.com/lisp/buildapp/[Buildapp].  This script takes
https://common-lisp.net/project/asdf/[ASDF] manifest file from `manifest`
environment variable.  By default, `manifest` is set to
`/m/config/common-lisp/sbcl-quicklisp-manifest.txt`.

.file::buildapp-cmpitg
[source,sh]
----
#!/usr/bin/env rc

if (~ $manifest '') {
	manifest='/m/config/common-lisp/sbcl-quicklisp-manifest.txt'
}

buildapp --manifest-file $manifest \
	--load /m/config/common-lisp/sbcl-base.lisp \
	$*

----

=== `symlink` - symlinks, prompting for overwriting if destination exists

.file::symlink
[source,sh]
----
#!/usr/bin/env sh

if [ "$#" -eq 1 ] && [ "${1}" = "--help" ]; then
	echo "Usage: ${0} <source> <destination>

Symlink <source> to <destination>.  If <destination> ends with a slash (/), it indicates a directory and the symlink is put in the directory.  Otherwise, prompt for overwriting <destination> if exists.  In case that <source> is a symlink, it is not followed."
	exit 0
fi

if [ "$#" -ne 2 ]; then
	echo "${0} requires 2 arguments: <source> and <destination>" >&2
	exit 2
fi

if [ -d "${2}" ] && [ ! -L "${2}" ]; then
	exec ln --interactive --verbose --symbolic "${1}" "${2}"
else
	exec ln --interactive --verbose --symbolic --no-target-directory "${1}" "${2}"
fi

----

=== `start-vpn` - connects to a VPN

Connects to a VPN using OpenVPN, taking the first argument as the path to the directory that contains the VPN configuration.  This script will automatically start the client VPN process in a Tmux session if not run in a TTY.

.file::start-vpn
[source,sh]
----
#!/usr/bin/env sh

vpn_dir_="${1:-${HOME}}"
vpn_path_=$(zenity --file-selection --multiple --filename="${vpn_dir_}")

if [ -n "${vpn_path_}" ]; then
	start_vpn_cmd_="cd $(dirname ${vpn_path_}) && sudo openvpn --config ${vpn_path_}"
    cd "$(dirname ${vpn_path_})"

	if [ -t 0 ]; then
		eval "${start_vpn_cmd_}"
	else
		term-emu -e "tmux new-session 'bash -c \"${start_vpn_cmd_}\"'"
	fi
fi

----

=== `list-broken-symlinks` - lists broken symlinks in a directory

TODO: `--help`

.file::list-broken-symlinks
[source,sh]
----
#!/usr/bin/env sh

dir_=$(readlink -f "${1:-.}")

for file_ in "${dir_}/"*; do
    if [ ! -e "${file_}" ]; then
        echo "${file_}"
    fi
done

----

=== `check-xinput` - checks if a device appears in `xinput list`

.file::check-xinput
[source,sh]
----
#!/usr/bin/env bash

set -o nounset

DISPLAY=${DISPLAY:-:0}

exec xinput list | grep "$@" >/dev/null 2>&1
----

=== `chmod-default [dir]` - fixes permissions

`chmod` a directory recursively, 755 for files and 644 for directories.  By
default, `dir` is current working directory.

.file::chmod-default
[source,sh]
----
#!/usr/bin/env bash

test -z "$1" && dir_="." || dir_="$1"

find "${dir_}" -type d -print0 | xargs -0 chmod 0755
find "${dir_}" -type f -print0 | xargs -0 chmod 0644

----

=== `cl-write-manifest` - writes ASDF manifest file

Writes
https://common-lisp.net/project/asia/asia.html#_how_to_create_project_manifest_database[ASDF
manifest] file to a location, set by environment variable `manifest`.  By
default, `manifest` is set to
`/m/config/common-lisp/sbcl-quicklisp-manifest.txt`.

.file::cl-write-manifest
[source,sh]
----
#!/usr/bin/env rc

if (~ $manifest '') {
	manifest='/m/config/common-lisp/sbcl-quicklisp-manifest.txt'
}

echo Writing manifest file $manifest

sbcl-cmpitg --no-userinit --no-sysinit --non-interactive \
	--eval '(ql:write-asdf-manifest-file "'^$manifest^'")'

----

=== `clojure-repl` - starts Clojure REPL with http://leiningen.org/[Lein]

Starts a Clojure REPL in a directory, set by the `clojure_root` environment
variable.  By default, `clojure_root` is set to `${HOME}/test/clojure/main`.

.file::clojure-repl
[source,sh]
----
#!/usr/bin/env rc

if (~ $clojure_root '') {
	clojure_root=$home/test/clojure/main
}

pushd .
cd $clojure_root
lein repl $@
popd

----

=== `comment-code` - comments code, read from stdin

Comments code by prefixing them with line comment character string by the
first argument passed in this script.  By default, prefix code with `# `.

.file::comment-code
[source,sh]
----
#!/usr/bin/env rc

#
# Comments a piece of code.
#

if (~ $1 '') {
	comment_char='#'
}
if not {
	comment_char=$1
}

prefix $comment_char^' '

----

=== `config-keymap-altgr` - keyboard layout: Programmer Dvorak + Right Alt as AltGr + Ctrl-Alt swapped + CapsLock-Escape swapped

.file::config-keymap-altgr
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

do-notify-short "Setting cmpitg's keyboard layout with Right Alt as AltGr"
setxkbmap us -variant dvp -option lv3:ralt_alt
xmodmap <( cat <<EOF
! -*- mode: xmodmap-generic -*-
! Clear modifier map for mod5 for now
clear mod5

add mod4 = Super_R

! Swap Escape and Capslock
remove Lock = Caps_Lock
add Lock = Escape
keysym Caps_Lock = Escape
keysym Escape = Caps_Lock

! Swap left Control and Alt
remove control = Control_L
remove mod1 = Alt_L
remove mod1 = Meta_L
keysym Control_L = Meta_L
keysym Control_L = Alt_L
keysym Alt_L = Control_L
add mod1 = Meta_L
add mod1 = Alt_L
add control = Control_L

! Swap right Control and Alt
remove control = Control_R
remove mod1 = Alt_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R

add control = Control_R

! Add AltGr to Alt_R
add mod5 = Alt_R

EOF
)

----

=== `config-keymap-standard` - keyboard layout: Programmer Dvorak + Ctrl-Alt swapped + CapsLock-Escape swapped

.file::config-keymap-standard
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

##############################################################################

do-notify-short "Setting cmpitg's keyboard layout"
setxkbmap us -variant dvp -option lv3:ralt_alt
xmodmap <( cat <<EOF
! -*- mode: xmodmap-generic -*-
! No modifier map for mod5
clear mod5
add mod4 = Super_R

! Swap Escape and Capslock
remove Lock = Caps_Lock
add Lock = Escape
keysym Caps_Lock = Escape
keysym Escape = Caps_Lock

! Swap left Control and Alt
remove control = Control_L
remove mod1 = Alt_L
remove mod1 = Meta_L
keysym Control_L = Meta_L
keysym Control_L = Alt_L
keysym Alt_L = Control_L
add mod1 = Meta_L
add mod1 = Alt_L
add control = Control_L

! Swap right Control and Alt
remove control = Control_R
remove mod1 = Alt_R
keysym Control_R = Alt_R
keysym Alt_R = Control_R
add mod1 = Alt_R
add control = Control_R

EOF
)

----

=== `config-inputs-cmpitg` - config keyboards, mice, ... all input devices

.file::config-inputs-cmpitg
[source,sh]
----
#!/usr/bin/env bash

# config-keymap-standard
config-keymap-altgr
config-logitech-trackball-marble-righty
# config-logitech-trackball-marble-lefty
config-logitech-g300-mouse
config-logitech-g502-mouse
config-lenovo-n700-mouse
config-touchpad
config-extra-peripherals

----

=== `config-keymap-steam` - keyboard layout: Programmer Dvorak without AltGr

Because Steam doesn't work with swapped modifiers.

.file::config-keymap-steam
[source,sh]
----
#!/usr/bin/env bash

test -z "${DISPLAY}" && exit 0

do-notify-short "Setting keyboard layout for Steam"
newline
setxkbmap us -variant dvp -option lv3:ralt_alt

config-logitech-g502-mouse

----

=== Config mouses & extra peripherals

Enables natural scrolling and tweaks acceleration profile.

==== `config-extra-peripherals`

.file::config-extra-peripherals
[source,sh]
----
#!/usr/bin/env bash

check-xinput 'DELL Laser Mouse' && (
	do-notify "Setting natural scrolling for Dell mouse"
	(
		xinput set-prop 'DELL Laser Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
		xinput set-prop 'DELL Laser Mouse' 'libinput Accel Speed' 0.2 &>/dev/null
	) || (
		xinput set-prop 'DELL Laser Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'Logitech USB Optical Mouse' && (
	do-notify 'Setting accel profile for Logitech USB Optical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'PS/2 Synaptics TouchPad' 'Device Accel Profile' 2
	xinput set-prop 'Logitech USB Optical Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Logitech USB Optical Mouse"
	(
		xinput set-prop 'Logitech USB Optical Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech USB Optical Mouse' 'Evdev Scrolling Distance' -1, -1, 1
	)
)

check-xinput 'Kingsis Peripherals Evoluent VerticalMouse 4' && (
	do-notify "Setting natural scrolling for Evoluent Vertical 4"
	(
		xinput set-prop 'Kingsis Peripherals Evoluent VerticalMouse 4' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Kingsis Peripherals Evoluent VerticalMouse 4' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'MOSART Semi. 2.4G Wireless Mouse' && (
	do-notify 'Setting accel profile for Anker Vertical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Anker Vertical mouse"
	(
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'MOSART Semi. 2.4G Wireless Mouse Mouse' && (
	do-notify 'Setting accel profile for Anker Vertical Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'Device Accel Profile' 2

	do-notify "Setting natural scrolling for Anker Vertical mouse"
	(
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'MOSART Semi. 2.4G Wireless Mouse Mouse' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'TPPS/2 IBM TrackPoint' && (
	do-notify "Setting natural scrolling for TPPS/2 IBM TrackPoint"
	(
		xinput set-prop 'TPPS/2 IBM TrackPoint' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'TPPS/2 IBM TrackPoint' 'Evdev Scrolling Distance' -1, -1, 1 &>/dev/null
	)
)

check-xinput 'PS/2 Synaptics TouchPad' && (
	do-notify 'Setting accel profile for PS/2 Synaptics TouchPad'
	# Polynomial - very usable, recommended
	xinput set-prop 'PS/2 Synaptics TouchPad' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for PS/2 Synaptics TouchPad'
	(
		xinput set-prop 'PS/2 Synaptics TouchPad' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation' 1
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation Button' 2
		xinput set-prop 'PS/2 Synaptics TouchPad' 'Evdev Wheel Emulation Axes' 7, 6, 5, 4
	)
)

check-xinput 'Logitech MX Vertical Advanced Ergonomic Mouse' && (
	do-notify 'Setting accel profile for Logitech MX Vertical Advanced Ergonomic Mouse'
	# Polynomial - very usable, recommended
	xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for Logitech MX Vertical Advanced Ergonomic Mouse'
	(
		xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech MX Vertical Advanced Ergonomic Mouse' 'Evdev Scrolling Distance' -1, -1, -1
	)
)

check-xinput 'Logitech MX Vertical' && (
	do-notify 'Setting accel profile for Logitech MX Vertical'
	# Polynomial - very usable, recommended
	xinput set-prop 'Logitech MX Vertical' 'Device Accel Profile' 2

	do-notify 'Setting natural scrolling for Logitech MX Vertical'
	(
		xinput set-prop 'Logitech MX Vertical' 'libinput Natural Scrolling Enabled' 1 &>/dev/null
	) || (
		xinput set-prop 'Logitech MX Vertical' 'Evdev Scrolling Distance' -1, -1, -1
	)
)

----

==== `config-lenovo-n700-mouse`

.file::config-lenovo-n700-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

id_=$( \
	xinput list 2>/dev/null \
	| grep "Dual Mode WL Touch Mouse N700" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

##############################################################################

do-notify-short "Configuring Dual Mode WL Touch Mouse N700
* Set natural scrolling
* Set pointer acceleration
"
{
	xinput set-prop "${id_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
} || {
	xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
}

xinput set-prop "${id_}" "Device Accel Profile" 7

----

==== `config-logitech-g300-mouse`

Also, resets keyboard layout for G300 back to US QWERTY, so that
kbd:[Ctrl+X/C/V] works as expected.

.file::config-logitech-g300-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

mouse_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G300" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)
keyboard_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G300" \
	| tail -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${mouse_}"    && exit 0
test -z "${keyboard_}" && exit 0

##############################################################################

do-notify-short "Configuring Logitech G300 mouse
* Set natural scrolling
* Reset keyboard layout
"
{
	xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
} || {
	xinput set-prop "${mouse_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
}
setxkbmap us -device "${keyboard_}"

----

==== `config-logitech-g502-mouse`

.file::config-logitech-g502-mouse
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

# http://www.x.org/wiki/Development/Documentation/PointerAcceleration/

##############################################################################

ids_=$( \
	xinput list \
	| grep "Logitech Gaming Mouse G502" \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${ids_}" && exit 0

##############################################################################

do-notify "Configuring Logitech G502 mouse
* Set natural scrolling
* Tuning mouse movement"

for mouse_ in ${ids_}; do
	echo "${mouse_}"

	{
		xinput set-prop "${mouse_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
	} || {
		xinput set-prop "${mouse_}" "Evdev Scrolling Distance" -1, -1, 1 &>/dev/null
	}

	xinput set-prop "${mouse_}" "Device Accel Profile" 7
	xinput set-prop "${mouse_}" "Device Accel Constant Deceleration" 2
	xinput set-prop "${mouse_}" "Device Accel Adaptive Deceleration" 1
done

----

==== `config-logitech-trackball-marble-lefty`

.file::config-logitech-trackball-marble-lefty
[source,sh]
----
#!/usr/bin/env bash

# Sources:
#   https://wiki.archlinux.org/index.php/Logitech_Marble_Mouse
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
#   http://www.x.org/archive/X11R7.5/doc/man/man4/evdev.4.html
#   man evdev

id_=$( \
	xinput list \
	| grep "Logitech USB Trackball" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

# ID        Hardware Action         Result
# 1     Large button left   normal click
# 2     Both large buttons  middle-click  †
# 3     Large button right  right-click
# 4     (not a button)  -
# 5     (not a button)  -
# 6     (not a button)  -
# 7     (not a button)  -
# 8     Small button left   browser back
# 9     Small button right  browser forward


# * big-left: Primary click
# * big-right: Secondary click
# * small-left: Scrolling
# * small-right: Middle click
do-notify-short """Config buttons for lefties:
   large-left  [1]: Right click
   large-right [3]: Left click
   small-left  [8]: Middle click
   small-right [9]: Scrolling + Middle click"""
newline
# xinput set-button-map "${id_}" 1 9 3 4 5 6 7 2 9
xinput set-button-map "${id_}" 3 9 1 4 5 6 7 2 2

# small-left
# xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 8
xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 9

# Enable wheel emulation
xinput set-prop "${id_}" "Evdev Wheel Emulation"        1

##############################################################################

do-notify-short "Config inverted and horizontial scrolling"

# For normal scrolling
# xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 6 7 4 5

# Inverted scrolling
xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 7 6 5 4

# Inverted direction
xinput set-prop "${id_}" "Evdev Axis Inversion" 1 1

##############################################################################

do-notify-short "Config profile: Fast movement but more control at pixel-level"
newline

# Default
# Debian
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5
xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5

# More precision
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 5
xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 1

# Acceleration
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
# xinput set-prop "${id_}" "Device Accel Profile" -1
# xinput set-prop "${id_}" "Device Accel Profile" 6
xinput set-prop "${id_}" "Device Accel Profile" 2
# Debian
xinput set-prop "${id_}" "Device Accel Velocity Scaling" 5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1

----

==== `config-logitech-trackball-marble-righty`

.file::config-logitech-trackball-marble-righty
[source,sh]
----
#!/usr/bin/env bash

# Sources:
#   https://wiki.archlinux.org/index.php/Logitech_Marble_Mouse
#   http://www.x.org/wiki/Development/Documentation/PointerAcceleration/
#   http://www.x.org/archive/X11R7.5/doc/man/man4/evdev.4.html
#   man evdev

id_=$( \
	xinput list \
	| grep "Logitech USB Trackball" \
	| head -1 \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

test -z "${id_}" && exit 0

# ID        Hardware Action         Result
# 1     Large button left   normal click
# 2     Both large buttons  middle-click  †
# 3     Large button right  right-click
# 4     (not a button)  -
# 5     (not a button)  -
# 6     (not a button)  -
# 7     (not a button)  -
# 8     Small button left   browser back
# 9     Small button right  browser forward


# * big-left: Primary click
# * big-right: Secondary click
# * small-left: Scrolling
# * small-right: Middle click
do-notify-short """Config buttons for righties:
   large-left  [1]: Left click
   large-right [3]: Right click
   small-left  [8]: Middle click
   small-right [9]: Scrolling + Middle click"""
newline
xinput set-button-map "${id_}" 1 9 3 4 5 6 7 2 9
# xinput set-button-map "${id_}" 3 9 1 4 5 6 7 2 2

# small-left
xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 8
# xinput set-prop "${id_}" "Evdev Wheel Emulation Button" 9

# Enable wheel emulation
xinput set-prop "${id_}" "Evdev Wheel Emulation"        1

##############################################################################

do-notify-short "Config inverted and horizontial scrolling"
newline

# For normal scrolling
# xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 6 7 4 5

# Inverted scrolling
xinput set-prop "${id_}" "Evdev Wheel Emulation Axes" 7 6 5 4

# Inverted direction
xinput set-prop "${id_}" "Evdev Axis Inversion" 1 1
# xinput set-prop "${id_}" "Evdev Axis Inversion" 0 1

##############################################################################

do-notify-short "Config profile: Fast movement but more control at pixel-level"
newline

# Default
# Debian
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5
# xinput set-prop "${id_}" "Device Accel Constant Deceleration" 1.5

# More precision
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 5
# xinput set-prop "${id_}" "Device Accel Adaptive Deceleration" 1

# Acceleration
# xinput set-prop "${id_}" "Device Accel Profile" -1
# xinput set-prop "${id_}" "Device Accel Profile" 6
xinput set-prop "${id_}" "Device Accel Profile" 2
# Debian
xinput set-prop "${id_}" "Device Accel Velocity Scaling" 5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1.5
# xinput set-prop "${id_}" "Device Accel Velocity Scaling" 1

----

==== `config-touchpad`

Lots of tweaks, the code should be self-explanatory though.

.file::config-touchpad
[source,sh]
----
#!/usr/bin/env bash

check-xinput -i "touchpad" || exit 0

id_=$( \
	xinput list \
	| grep -i 'synaptics touchpad' \
	| cut -d'=' -f2 \
	| awk '{ print $1 }' \
)

scrolling_distance_2_=$(xinput list-props ${id_} \
	| grep 'Synaptics Scrolling Distance' \
	| gnu-awk '{ print $NF }' \
	| sed 's/-//g' \
)
scrolling_distance_1_=$(xinput list-props ${id_} \
	| grep 'Synaptics Scrolling Distance' \
	| gnu-awk '{ print $(NF - 1) }' \
	| cut -d',' -f1 \
	| sed 's/-//g' \
)

##############################################################################

do-notify-short """Configuring touchpad
* Setting natural scrolling
* Enabling tapping
* Enabling two-finger tapping as secondary click"""
newline

# Edge
# synclient LeftEdge=1200
# synclient RightEdge=5100
# synclient TopEdge=1000
# synclient BottomEdge=4600

# synclient LeftEdge=1000
# synclient RightEdge=5200
# synclient TopEdge=1000
# synclient BottomEdge=5000

# Palm detection
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient PalmDetect=1

# Tap
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient MaxTapTime=180
# synclient MaxTapMove=221
# synclient MaxDoubleTapTime=100
# synclient SingleTapTimeout=180
# synclient EmulateTwoFingerMinZ=1
# synclient EmulateTwoFingerMinW=7
# synclient VertEdgeScroll=1
# synclient HorizEdgeScroll=1

# Corner
## Wed, 27 Jul 2016 23:22:03 +0300 - Disable because it's no longer relevant
# synclient RTCornerButton=0
# synclient RBCornerButton=0
# synclient LTCornerButton=1
# synclient LBCornerButton=0
# synclient TapButton1=1
# synclient TapButton2=3
# synclient TapButton3=2
# synclient ClickFinger1=1
# synclient ClickFinger2=1
# synclient ClickFinger3=2
# synclient CircularScrolling=0

# Natural scrolling
# synclient VertScrollDelta=-111
# synclient HorizScrollDelta=-111
# synclient VertEdgeScroll=0
# synclient HorizEdgeScroll=0

##############################################################################

(
	xinput set-prop "${id_}" "libinput Tapping Enabled" 0 &>/dev/null
	xinput set-prop "${id_}" "libinput Natural Scrolling Enabled" 1 &>/dev/null
) || (
	xinput set-prop "${id_}" "Synaptics Scrolling Distance" "-${scrolling_distance_1_}" "-${scrolling_distance_2_}" &>/dev/null
	xinput set-prop "${id_}" "Synaptics Two-Finger Scrolling" 1, 1 &>/dev/null
)

# xinput get-button-map "SynPS/2 Synaptics TouchPad" 1 2 3 4 5 6 7 8 9 10 11 12

----

=== `config-monitors-default` - configs all monitors with default settings from XRandR

.file::config-monitors-default
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables xrandr XRandR get-all-randr-outputs get-all-randr-outputs sed "GNU Sed" tr Coreutils || exit 1

get-all-randr-outputs | sed 's/$/ --auto/g; s/^/--output /g' | tr "\n" " " | xargs xrandr

----

=== `config-monitors-urt` - configs external monitor for http://www.urbanterror.info[Urban Terror]

Disables laptop monitor and increases brightness, as the brightness option
doesn't work in-game.

.file::config-monitors-urt
[source,sh]
----
#!/usr/bin/env rc

laptop_mon=eDP1
main_mon=HDMI1
gamma=1.4

xrandr --output $laptop_mon --off
sleep 2
xrandr --output $main_mon --mode 1280x1024
xrandr --output $main_mon --gamma $gamma:$gamma:$gamma

----

=== `audio-toggle-mute`

.file::audio-toggle-mute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id toggle
}

----

=== `audio-unmute`

.file::audio-unmute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id 0
}

----

=== `audio-mute`

.file::audio-mute
[source,sh]
----
#!/usr/bin/env rc

ids=`{ \
	pactl list sinks short \
	| awk '{ print $1 }'
}

for (id in $ids) {
	pactl set-sink-mute $id 1
}

----

=== `extract-audio`

Extracts from a video file, creating the same file name with appropriate
extension.

.file::extract-audio
[source,sh]
----
#!/bin/zsh

setopt shwordsplit

report-missing-executables ffmpeg Ffmpeg || exit 1

file_="$1"

ffmpeg -i "${file_}" -vn -acodec copy \
	"$file_:r.$(ffprobe ${file_} 2>&1 | grep Audio | sed -rn 's/.*Audio: ([^ ]*).*/\1/p')"

----

=== `convert-to-mp3` - converts files to MP3

This script takes a list of files as arguments.

.file::convert-to-mp3
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables ffmpeg Ffmpeg || exit 1

for (f in $*) {
	new_name=`{echo $f | replace-extension mp3}
	ffmpeg -i $f -vn -aq 1 $"new_name
}

----

=== `convert-to-ogg-vorbis` - converts files to Ogg Vorbis

This script takes a list of files as arguments.

.file::convert-to-ogg-vorbis
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables ffmpeg Ffmpeg || exit 1

for (f in $*) {
	new_name=`{echo $f | replace-extension ogg}
	ffmpeg -i $f -vn -aq 1 $"new_name
}

----

=== `count-monitors`

.file::count-monitors
[source,sh]
----
#!/usr/bin/env bash

xrandr | grep " connected" | wc -l

----

=== `cpu-usage`

Returns the average CPU usage measured in 3 consecutive seconds, using `mpstat`.

.file::cpu-usage
[source,sh]
----
#!/usr/bin/env bash

#
# Using `mpstat', calculates average CPU usage in 3 seconds.
#

report-missing-executables mpstat Sysstat || exit 1

mpstat 3 1 | tail -1 | gawk '$12 ~ /[0-9.]+/ { print 100 - $12"%" }'

----

=== `create-ctags`

.file::create-ctags
[source,sh]
----
#!/usr/bin/env bash

#
# Creates a tags file named TAGS using ctags.
#

report-missing-executables tags "Ctags or Exuberant Ctags" || exit 1

if test -z "$1"; then
	cat <<EOF
Usage: $0 <directory> [ctags-options]*

Creates a tags file named TAGS using ctags.
EOF
	exit 2
fi

dir_name_="$1"
shift

ctags "$@" -f "${dir_name_}"/TAGS -R "${dir_name_}"/*

----

=== `create-sbcl-cmpitg-image` - dumping a customized SBCL image

Dumps a customized SBCL image and makes it work with Shelly (if installed).

.file::create-sbcl-cmpitg-image
[source,sh]
----
#!/usr/bin/env rc

if (~ $1 -h --help) {
	cat <<EOF
	exit 1
}
Dumps an SBCL image and makes it work with Shelly (if installed).

Usage: $0 [--core-path core-file] [--eval sexp]

Options:

--core-path :: Path to SBCL core file to dump to, default value:
               '/m/opt/sbcl-images/sbcl-base.core'.
--eval      :: The Sexp to evaluate before dumping, default value:
               '(load "/m/config/common-lisp/sbcl-base.lisp")'.
EOF

##############################################################################
# Sanity check
##############################################################################

report-missing-executables sbcl SBCL || exit 1

sbcl_version=`{sbcl --version | cut -d' ' -f2}

##############################################################################

fn try_set_vars {
	switch ($1) {
	case --core-path
		core_path=$2
	case --eval
		sexp=$2
	}

	if (~ $core_path '') {
		core_path=/m/opt/sbcl-images/sbcl-base.core
	}
	if (~ $sexp '') {
		sexp='(load "/m/config/common-lisp/sbcl-base.lisp")'
	}
}

try_set_vars $1 $2
try_set_vars $3 $4

if (! ~ $SHELLY_HOME '') {
	shelly_core_path=$SHELLY_HOME^'/dumped-cores/sbcl-'^$sbcl_version^'.core'
}

##############################################################################

echo Core path: $core_path
echo Sexp: $sexp
if (! ~ $shelly_core_path '') {
	echo Shelly found, path to core: $shelly_core_path
}

echo '-> Dumping core'
sbcl --noinform \
	--no-userinit \
	--eval $sexp \
	--eval '(sb-ext:save-lisp-and-die "'^$core_path^'")'

if (test -d $SHELLY_HOME/dumped-cores) {
	echo '-> Updating Shelly'
	cp -fv $core_path $shelly_core_path
	cp -fv $core_path $SHELLY_HOME/dumped-cores/sbcl.core
}

----

=== `sbcl-cmpitg`

.file::sbcl-cmpitg
[source,sh]
----
#!/usr/bin/env bash

#
# Note that --no-userinit should be after "$@", at the position of
# `user-options'.  Consult `sbcl --help' for further information.
#

sbcl --noinform --core /m/opt/sbcl-images/sbcl-base.core "$@" --no-userinit

----

=== `json-post` - makes a JSON POST

.file::json-post
[source,sh]
----
#!/usr/bin/env rc

#
# Makes a JSON POST with Curl
#

report-missing-executables curl cURL || exit 1

curl -i -H 'Content-Type: application/json' -X POST $*

----

=== `do-notify` - sends a desktop notification

.file::do-notify
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables notify-send Libnotify || exit 1

echo "$@"
exec notify-send "$@"

----

=== `do-notify-short` - sends a short desktop notification

.file::do-notify-short
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables notify-send Libnotify || exit 1

echo "$@"
exec notify-send -t 2000 "$@"

----

=== `docker-remove-orphaned-containers`

.file::docker-remove-orphaned-containers
[source,sh]
----
#!/usr/bin/env bash

docker rm $(docker ps -aq)

----

=== `docker-remove-unnamed-images`

.file::docker-remove-unnamed-images
[source,sh]
----
#!/usr/bin/env bash

docker images -a | grep "<none>" | awk '{ print $3 }' | xargs docker rmi

----

=== `drop-lines`

.file::drop-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Drops the first $1 lines.
#

n_lines=$1
n_lines=`{echo $n_lines + 1 | bc}
tail -n +$n_lines

----

=== `in_epoch2datetime` - converts the epoch from read from stdin to local date time

This script is particularly helpful when using with Emacs/Acme, e.g. called with a text selection.

.file::in_epoch2datetime
[source,sh]
----
#!/usr/bin/env sh

epoch_=$(cat)

exec date --date="@${epoch_}" -R

----

=== `en2fi` - translates from English to Finnish

.file::en2fi
[source,sh]
----
#!/usr/bin/env rc

#
# Translates from English to Finnish with Google Translate, using
# soimort/translate-shell tool.
#

report-missing-executables trans soimort/translate-shell || exit 1

TARGET_LANG=fi gtranslate $*

----

=== `fi2en` - translates from Finnish to English

.file::fi2en
[source,sh]
----
#!/usr/bin/env rc

#
# Translates from Finnish to English with Google Translate, using
# soimort/translate-shell tool.
#

report-missing-executables trans soimort/translate-shell || exit 1

TARGET_LANG=en gtranslate $*

----

=== `format-text` - formats text from stdin using Emacs's `fill-paragraph`

.file::format-text
[source,sh]
----
#!/usr/bin/env rc

#
# Formats text from stdin using Emacs's fill-paragraph.
#

input=`{cat}
sexpr=`{echo `{cat <<EOF}}

(with-temp-buffer
  (set-fill-column 78)
  (insert "$input")
  (end-of-buffer)
  (fill-region 0 (point))
  (princ (buffer-string)))
EOF

emacs --batch --eval $"sexpr $* >[2]/dev/null

----

=== `monitors-info` - retrieves information of connected monitors

.file::monitors-info
[source,sh]
----
#!/usr/bin/env rc

#
# Retrieves information of the currently connected monitors and outputs as
# followed:
# * First line: <number of monitors>
# * Second line: <monitor> <mode> <rate>
#

lines=`{xrandr \
	| grep ' connected' \
	| cut -d' ' -f1}

echo $#lines
for (output in $lines) {
	data=`{xrandr \
		| take-from $output \
		| drop-lines 1 \
		| take-lines 1 \
		| tr -d '*' \
		| tr -d '+'}
	mode=`{echo $data | cut -d' ' -f1}
	rate=`{echo $data | cut -d' ' -f2}
	echo $output $mode $rate
}

----

=== `replace-extension` - replaces file extension

.file::replace-extension
[source,sh]
----
#!/usr/bin/env rc

input=`{cat}

if (~ $1 '') {
	echo Usage: $0 '<'replacement'>' >[1=2]
	exit 1
}

rev_replacement=`{echo $1 | rev}

echo $input | rev | sed 's/^[^.]*\./'$rev_replacement'./' | rev

----

=== `git-rm-orphaned` - removes orphaned files from Git

.file::git-rm-orphaned
[source,sh]
----
#!/usr/bin/env bash

git ls-files --deleted | xargs git rm --cached

----

=== `uri-github2ssh` - converts Github URI to `git+ssh` style

.file::uri-github2ssh
[source,sh]
----
#!/usr/bin/env rc

#
# git@github.com:schacon/hg-git.git
# git+ssh://git@github.com/schacon/hg-git.git
#

program=`{basename $0}

if (~ $1 '' '--help') {
	cat <<USAGE
	exit 1
}
Usage: $program git@github.com:<user>/<repo>

Converts to universal git+ssh style repository URI.

E.g.

  $program git@github.com:schacon/hg-git.git
  # ⇨ git+ssh://git@github.com/schacon/hg-git.git
USAGE

uri=`{echo $1 | sed 's/:/\//g' | sed 's/git\/\/\///g'}

echo 'git+ssh://'$uri

----

=== `gitserve` - runs a Git server

.file::gitserve
[source,sh]
----
#!/usr/bin/env rc

#
# Runs a Git server.
#

program=`{basename $0}

if (~ $1 '-h' '--help') {
	cat <<USAGE
	exit 0
}
Usage:

Runs a Git server.

  $program             :: Take current directory as Git repository
  $program <git-repo>  :: Take a specific Git repository

By default, the Git server is opened on port 4242.  This could be overriden by
setting the environment variable GIT_PORT.  For example: run a Git server on
port 5454, serving content from Git repo at /m/bin:

  GIT_PORT=5454 $program /m/bin

Then, you can clone the repo with: git clone git://<host>:<port>/ <repo-name>

Note that this method is a quick way to share Git repository and it's not at
all secure.  In practice, you might want to Git server behind a reverse proxy.
USAGE

(test $#GIT_PORT -eq 0) && git_port=4242 || git_port=$GIT_PORT
(test $#1        -eq 0) && git_path='.'  || git_path=$1

exec git daemon --reuseaddr '--base-path='$git_path --export-all --verbose '--port='$git_port

----

=== `get-all-randr-outputs` - gets all RandR outputs

.file::get-all-randr-outputs
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables xrandr XRandR ag Ag awk "GNU Awk" || exit 1

xrandr | ag connected | awk '{ print $1 }'

----

=== `get-all-execs` - gets all executables, optionally prefixed with a string and history support

.file::get-all-execs
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require cmdline

if {[catch {exec report-missing-executables find "GNU Find" sort Coreutils <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

proc usage {{fd stdout}} {
    puts $fd {get-all-execs

Get all executables from the PATH environment variables, sort in ascending order, deduplicate, and return them one line per entry.}
}

proc getAccessiblePaths {} {
    set rawPaths [exec echo $::env(PATH) | sed {s/:/\n/g} | sort | uniq]
    set res {}
    foreach path $rawPaths {
        if {[file exists $path]} {
            lappend res "$path/"
        }
    }
    return $res
}

if {$::argv == "--help"} {
    usage
}
if {$::argc != 0} {
    usage stderr
    exit 1
}

set paths [getAccessiblePaths]
set execs [exec find {*}$paths -maxdepth 1 -type f,l -executable | awk {FS="/" { print $NF }} | sort -u]
catch {puts $execs}

----

=== `gtranslate` - translates from stdin with Google Translate

.file::gtranslate
[source,sh]
----
#!/usr/bin/env rc

#
# Translates with Google Translate, using soimort/translate-shell tool.
#

if (! which trans >/dev/null >[2=1]) {
	echo trans command not found >[1=2]
	echo Make sure you have soimort/translate-shell installed >[1=2]
	exit 1
}

input=`{cat}
trans $* -brief $"input

----

=== `html2text`

.file::html2text
[source,sh]
----
#!/usr/bin/env bash

#
# Converts HTML to text.  HTML is read from stdin.
#

report-missing-executables lynx Lynx || exit 1

exec lynx -dump -stdin "$@"

----

=== `i3-exec-command` - executes an http://i3wm.org/[i3] command

.file::i3-exec-command
[source,sh]
----
#!/usr/bin/env bash

i3-input -f 'pango:Noto Sans 10' "$@"

----

=== `i3-move-to-workspace` - moves a window to a workspace with http://i3wm.org/[i3]

.file::i3-move-to-workspace
[source,sh]
----
#!/usr/bin/env bash

i3-input \
	-f 'pango:Noto Sans 10' \
	-F 'move workspace "%s"' \
	-P 'Move window to workspace: ' %s

----

=== `i3-rename-workspace` - renames current workspace in http://i3wm.org/[i3]

.file::i3-rename-workspace
[source,sh]
----
#!/usr/bin/env bash

i3-input \
	-f 'pango:Noto Sans 10' \
	-F 'rename workspace to "%s"' \
	-P 'Rename workspace: ' %s

----

=== `switch-window` - window switcher

Requirement: `rofi`.

.file::switch-window
[source,sh]
----
#!/usr/bin/env sh


=== `set-1-monitor-default`

.file::set-1-monitor-default
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx

if {[catch {exec report-missing-executables get-all-randr-outputs get-all-randr-outputs >@ stdout 2>@ stderr}]} {
   exit 1
}

set monitors [string trim [exec get-all-randr-outputs]]
set primaryMonitor [lindex $monitors 0]
set otherMonitors [lrange $monitors 1 end]

set cmd [list "--output" $primaryMonitor "--auto"]
foreach monitor $otherMonitors {
    set cmd [list {*}$cmd "--output" $monitor "--off"]
}
report-missing-executables run-menu run-menu || exit 1

execl "xrandr" $cmd

----

=== `set-only-monitors` - sets and configs only certain monitors, all others are off

.file::set-only-monitors
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx

if {[catch {exec report-missing-executables get-all-randr-outputs get-all-randr-outputs >@ stdout 2>@ stderr}]} {
    exit 1
}

proc getSetMonitors {} {
    set res {}
    set takeNow 0
    foreach cmdArg $::argv {
        # We take the argument right after the --output argument
        if {$cmdArg eq "--output"} {
            set takeNow 1
        } elseif {$takeNow} {
            lappend res $cmdArg
            set takeNow 0
        }
    }
    return $res
}

proc filterMonitors {setMonitors monitors} {
    set res {}
    foreach monitor $monitors {
        if {[lsearch $setMonitors $monitor] == -1} {
            lappend res $monitor
        }
    }
    return $res
}

set setMonitors [getSetMonitors]
set allMonitors [string trim [exec get-all-randr-outputs]]
set monitors [filterMonitors $setMonitors $allMonitors]

set cmd [list {*}$::argv]
foreach monitor $monitors {
    set cmd [list {*}$cmd "--output" $monitor "--off"]
}

puts "xrandr $cmd"
execl "xrandr" $cmd

----


----





----




----

=== Running applications

==== Clipboard manager

.file::run-clipboard-manager
[source,sh]
----
#!/usr/bin/env sh

pidof clipit >/dev/null 2>&1 || exec clipit

----

==== Power manager

.file::run-power-manager
[source,sh]
----
#!/usr/bin/env sh

pkill xfce4-power-manager
exec xfce4-power-manager --no-daemon

----

==== Volume daemon

.file::run-volumed
[source,sh]
----
#!/usr/bin/env sh

# pkill xfce4-volumed
# exec xfce4-volumed --no-daemon

pkill pasystray
exec pasystray

----

==== Input method daemon with Ibus
+
.file::run-ibus-daemon
[source,sh]
----
#!/usr/bin/env sh

exec ibus-daemon -xvr

----

==== Screenshot manager

.file::run-screenshot-manager
[source,sh]
----
#!/usr/bin/env sh

----

==== Screensaver daemon

.file::run-screensaverd
[source,sh]
----
#!/usr/bin/env sh

pidof xscreensaver >/dev/null 2>&1 || exec xscreensaver

----

==== Network manager

.file::run-network-manager
[source,sh]
----
#!/usr/bin/env sh

pkill nm-applet
exec nm-applet --sm-disable

----

==== GNOME settings daemon

.file::run-settings-daemon
[source,sh]
----
#!/usr/bin/env sh

pidof gnome-settings-daemon >/dev/null 2>&1 || exec gnome-settings-daemon

----

==== Insync

.file::run-insync
[source,sh]
----
#!/usr/bin/env sh

pidof insync >/dev/null 2>&1 || exec insync start

----

==== Menu program

.file::run-menu
[source,sh]
----
#!/usr/bin/env sh

exec rofi -lines 40 \
	-width 85 \
	-font "Go Mono 11" \
	-kb-row-select Tab \
	-kb-row-tab "" \
	-kb-accept-alt "" \
	-kb-row-up Super+c,Up,Control+p \
	-kb-row-down Super+t,Down,Control+n \
	-kb-row-left Super+h,Left,Control+b \
	-kb-row-right Super+n,Right,Control+f \
	-kb-move-front Super+d,Control+a \
	-kb-move-end Super+D,Control+e \
	-kb-move-word-back Super+g,Alt+b \
	-kb-move-word-forward Super+r,Alt+f \
	-kb-accept-custom Shift+Return \
	"$@"

----

==== Application launcher

.file::run-app-launcher
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require Tclx
package require cmdline

if {[catch {exec report-missing-executables get-all-execs get-all-execs run-menu run-menu add-to-history add-to-history <@ stdin >@ stdout 2>@ stderr}]} {
    exit 1
}

try {
    array set cmdArgs [::cmdline::getoptions ::argv {
        {history-file.arg "~/.local/app-runner-history" "Application history file"}
        {max-history.arg  256                           "Maximum number of entries in the history"}
        {prefix.arg       "!@ "                         "String with which each executable is prefixed"}
    } {[--history-file <app-runner-history>] [--prefix <prefix>]
    
Run a fuzzy searcher tool with all the executables found in the PATH environment variable and from a history file.  The result of the search is then executed based on predefined patterns as follows.

* '!@ <command> [args...]' :: Run the command in a terminal emulator
* '!! <command> [args...]' :: Run the command in a terminal emulator, pause and prompt for exiting when after the command finishes
* '<url>' :: Open the URL with 'web-browser-gui'
* '<file-path>' :: Open the file path with a text editor
* 'dir:<dir-path>'  :: Open the directory using 'dir-browser-gui'

TODO: More patterns are later supported using Plan9port's Plumber.
}]} trap {CMDLINE USAGE} {msg _o} {
    if {[llength $::argv] == 0} {
        puts $msg
        exit 0
    } else {
        puts stderr $msg
        exit 1
    }
}

proc readHistory {path} {
    if {[file exists $path]} {
        set fd [open $path r]
        set data [read $fd]
        close $fd
        return $data
    } else {
        return ""
    }
}

proc addToHistory {path maxHistory text} {
    set fd [open "| add-to-history --max-history $maxHistory $path" w]
    puts $fd $text
    close $fd
}

proc getChoice {history execs} {
    set fd [open "| run-menu -dmenu -p \"Text: \" " r+]
    puts -nonewline $fd $history
    puts -nonewline $fd $execs
    set res [read $fd]
    return [string trim $res]
}

set historyFile [file normalize $cmdArgs(history-file)]
set maxHistory $cmdArgs(max-history)
set prefix $cmdArgs(prefix)

set execs [exec get-all-execs | sed "s/^/$prefix/g"]
set history [readHistory $historyFile]
set choice [getChoice $history $execs]

if {$choice ne ""} {
    addToHistory $historyFile $maxHistory $choice
    switch -glob $choice {
        "!@*" {
            set cmd [string replace $choice 0 1]
            execl with-term-emu-detach {*}$cmd
        }
        "!!!*" {
            set cmd [string replace $choice 0 1]
            execl with-term-emu [list {*}$cmd]
        }
        "!!*" {
            set cmd [string replace $choice 0 1]
            execl with-term-emu [list with-pause {*}$cmd]
        }
        default {
            execl run-menu [list "-e" "Error: Unrecoginzed pattern: $choice"]
        }
    }
}

----

.file::run-rmacs-rocket
[source,sh]
----
#!/usr/bin/env dash

exec wihack -type toolbar rmacs --shape utils --new-frame eval '(rocket:show-command-runner-with-dedicated-frame)'
# exec rmacs --shape utils --new-frame eval '(prog1 (rocket:show-command-runner-with-dedicated-frame) (~wmii/set-frame-floating))'
# exec run-menu -modi run,drun -show run -sidebar-mode "$@"

----

==== Google Chrome

.file::run-chrome
[source,sh]
----
#!/usr/bin/env sh

# exec google-chrome --remote-debugging-port=${CHROME_REMOTE_DEBUGGING_PORT:-9222} "$@"
exec google-chrome "$@"

----

==== Whatsapp

.file::run-whatsapp
[source,sh]
----
#!/usr/bin/env sh

# exec run-chrome --app=https://web.whatsapp.com/ "$@"
exec chromium --app=https://web.whatsapp.com/ "$@"

----

==== Drop-down terminal emulator

.file::run-drop-down-term-emu
[source,sh]
----
#!/usr/bin/env sh

exec guake "$@"

----

==== Desktop calendar

.file::run-calendar
[source,sh]
----
#!/usr/bin/env sh

exec run-chrome --app=https://calendar.google.com "$@"

----

=== `disable-x-bell`

.file::disable-x-bell
[source,sh]
----
#!/usr/bin/env sh

exec xset b off

----

=== `add-to-history`

TODO: Add description

.file::add-to-history
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8
package require cmdline
package require struct::list 1.8

try {
	array set cmdArgs [::cmdline::getoptions ::argv {
		{max-history.arg 1000 "Maximum number of items stored in the history"}
	} {[--max-history <max-history>] <history-file-path>

TODO: Documentation
}]} trap {CMDLINE USAGE} {msg _o} {
	if {[llength $::argv] == 0} {
		puts $msg
		exit 0
	} else {
		puts stderr $msg
		exit 127
	}
}

# TODO: Handle errors or missing arguments

set maxHistory $cmdArgs(max-history)
set filePath [lindex $::argv 0]

##############################################################################
# Helpers
##############################################################################

proc slurpIntoLines {path} {
	set fd [open $path r]
	set res [read $fd]
	close $fd
	return [::struct::list filterfor x [split $res "\n"] {[string trim $x] ne ""}]
}

proc readLineFromStdin {} {
	gets stdin line
	return [string trim $line]
}

proc writeLines {path lines} {
	set fd [open $path w]
	puts $fd [join $lines "\n"]
	close $fd
}

##############################################################################
# Main
##############################################################################

if {![file exists $filePath]} {
	set baseDir [file dirname $filePath]
	if {![file exists $baseDir]} {
		file mkdir $baseDir
	}

	# Create the empty file
	close [open $filePath w]

	set lines {}
} else {
	set lines [slurpIntoLines $filePath]
}

set newLine [readLineFromStdin]
set newLines [concat [list $newLine] [::struct::list filterfor x $lines {$x ne $newLine}]]
set finalLines [lrange $newLines 0 [expr {$maxHistory - 1}]]

writeLines $filePath $finalLines

puts $newLine

----

=== `join-lines`

Joins all lines using Plan 9's tr.

.file::join-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Joins all lines into one using Plan 9's tr.
#

exec tr '
' ' '
----

=== `all-dev-debs` - lists all Debian `-dev` packages installed

.file::all-dev-debs
[source,sh]
----
#!/usr/bin/env bash

dpkg-query -l '*dev' | grep "^.i" | awk '{ print $2 }' | grep "\-dev$"

----

=== `add-deb-repo` - adds a Debian-based repository

.file::add-deb-repo
[source,sh]
----
#!/usr/bin/env bash

usage() {
	cat <<EOF
add-deb-repo <sources-repo.list> <dest-repo.list>

Add a Debian-compatible sources.list file to global repository.  Should there be a command to run after adding, put it as a comment on the first line of the sources.list file.
EOF
}

if [[ "${1}" = "--help" ]]; then
	usage
	exit 0
fi

if [[ "$#" -ne 2 ]]; then
	usage >&2
	exit 1
fi

repo_path_="${1}"
dest_="/etc/apt/sources.list.d/${2}"

with-sudo symlink "${repo_path_}" "${dest_}"

if [[ "$(cat ${repo_path_})" == "#"* ]]; then
	eval $(head -1 "${repo_path_}" | cut -d'#' -f2)
fi

----

=== `local-tcp-open-p` - checks if a local TCP port is opened

.file::local-tcp-open-p
[source,sh]
----
#!/usr/bin/env bash

if (test $# -eq 0); then
	cat <<EOF
Usage: `basename $0` <port>

Determines if a local TCP port is open.  Returns 0 if it is or 1 otherwise.
EOF
fi

report-missing-executables nc Netcat || exit 1

exec nc -z 127.0.0.1 "$1"

----

=== `lockscreen`

.file::lockscreen
[source,sh]
----
#!/usr/bin/env bash

# pgrep lightdm && gdmflexiserver || gnome-screensaver-command -l
xscreensaver-command -lock \
	|| gnome-screensaver-command -l \
	|| (sh -c "dbus-send --type=method_call --dest=org.gnome.ScreenSaver /org/gnome/ScreenSaver org.gnome.ScreenSaver.Lock")

----

=== `monitor-off`

.file::monitor-off
[source,sh]
----
exec xset -display :0 dpms force off

----

=== `now-standardized`

.file::now-standardized
[source,sh]
----
#!/usr/bin/env sh

report-missing-executables date Coreutils tr Coreutils || exit 1

exec date --rfc-3339=second | tr ' ' '_'

----

=== `now-to-clipboard`

.file::now-to-clipboard
[source,sh]
----
#!/usr/bin/env bash

xterm -e 'date -R | xsel -b'

----

=== `symlink-p`

.file::symlink-p
[source,sh]
----
#!/usr/bin/env sh

#
# Determines if a file is a symbolic link
#

test -L "$@"

----

=== `filter-broken-symlinks [path1] [path2] [...]`

TODO: `--help`

.file::filter-broken-symlinks
[source,sh]
----
#!/usr/bin/env bash

#
# Filter broken symlinks from the argument list
#

for file_ in "$@" ; do
    if [ ! -e "${file_}" ]; then
        echo "${file_}"
    fi
done

----

=== `prompt-y-n` - prompts for a yes/no answer

Prompts a yes/no answer, exiting with code 0 for yes and non-zero for no.

.file::prompt-y-n
[source,tcl]
----
#!/usr/bin/env tclsh

proc getDefaultChoice {choice} {
	if {[string equal "" $choice]} {
		return "y"
	} else {
		return $choice
	}
}

proc getAnswer {default} {
	set answer [gets stdin]
	if {[string equal "" $answer]} {
		return $default
	} else {
		return $answer
	}
}

set prompt [lindex $argv 0]
set defaultChoice [getDefaultChoice [lindex $argv 1]]

puts -nonewline "$prompt \[y/n\] ($defaultChoice) "
flush stdout

set answer [getAnswer $defaultChoice]
if {[string equal "y" $answer]} {
	exit 0
} else {
	exit 1
}

----

=== `executable-exists <exec-file>` - checks if an executable exists in `PATH`

Checks whether an executable exists in one of the `PATH`s, returning exit code 0 if it does and 127 otherwise.

.file::executable-exists
[source,sh]
----
#!/usr/bin/env sh

command -v "$@" >/dev/null 2>&1

----

=== `report-missing-executables <bin-1> <software-1> <bin-2> <software-2> ...`

Reports missing software by checking if their corresponding executables exist.  If all executables are found, exit with status 0; otherwise, exit with status 1.

Sample usage:

[source,sh]
----
report-missing-executables aria2c Aria2 wget Wget
# ⇨
# aria2c and wget not found
# Make sure you have Aria2 and Wget installed

report-missing-executables aria2c Aria2 wget Wget curl cURL
# ⇨
# aria2c, curl, and wget not found
# Make sure you have Aria2, Wget, and cURL installed

report-missing-executables aria2c Aria2 wget
# ⇨
# Invalid arguments.  Number of arguments must be even.

----

.file::report-missing-executables
[source,python]
----
#!/usr/bin/env python3

import sys
import os


def main():
	if os.environ.get('DOCTEST') == '1':
		import doctest
		doctest.testmod()
		sys.exit(0)

	if len(sys.argv) == 1:
		show_help(when_error=True)
	elif len(sys.argv) == 2 and sys.argv[1] == "--help":
		show_help()
	elif len(sys.argv) % 2 == 0:
		sys.stderr.write("Invalid arguments.  Number of arguments must be even.\n")
		sys.exit(3)
	else:
		sys.exit(
			1 if report_missing_execs(get_missing_execs(sys.argv[1:])) else 0
        )


def show_help(when_error=False):
	help_text = """
Usage:
  report-missing-executables <exec-1> <prog-1> ...
  report-missing-executables --help

Reports missing software by checking if their corresponding executables exist.
If all executables are found, exit with status 0; otherwise, exit with status
1.

E.g.

  report-missing-executables aria2c Aria2 wget Wget
    # aria2c and wget not found
    # Make sure you have Aria2 and Wget installed

  report-missing-executables aria2c Aria2 wget Wget curl cURL
    # aria2c, curl, and wget not found
    # Make sure you have Aria2, Wget, and cURL installed

  report-missing-executables aria2c Aria2 wget
    # Invalid arguments.  Number of arguments must be even.

Development note: When running with environment variable DOCTEST set to 1,
runs the Python doctest and exits.
"""
	if when_error:
		sys.stderr.write(help_text)
	else:
		sys.stdout.write(help_text)


def find_executable(name):
	"""If `name` is an executable, returns the full path to `name`; otherwise,
	returns `False`.

	>>> find_executable("ls")
	'/bin/ls'
	>>> import uuid
	>>> find_executable(str(uuid.uuid4()))
	False
	"""
	paths = os.environ.get("PATH", "").split(":")

	for path_dir in paths:
		full_path = os.path.join(path_dir, name)
		if (os.path.isfile(full_path) and os.access(full_path, os.X_OK)):
			return full_path

	return False


def found_executable(name):
	"""Determines if a name is an executable that can be called.

	>>> found_executable("ls")
	True
	>>> found_executable("python")
	True
	>>> import uuid
	>>> found_executable(str(uuid.uuid4()))
	False
	"""
	return find_executable(name) != False


def get_missing_execs(args):
	"""Gets missing executables from command line arguments.  The argument `args`
	is a list of strings `<exec-1> <program-1> <exec-2> <program-2> ...`.
	Returns the list of dictionaries with `\"executable\"` and `\"program\"`
	as keys where the corresponding executables are not found.

	>>> get_missing_execs(['ls', 'Binutils', 'python', 'Python', 'aaaSomeCrapaaa', 'Some Crap']) == [{'executable': 'aaaSomeCrapaaa', 'program': 'Some Crap'}]
	True
	"""
	return [
		dict(executable=args[i], program=args[i + 1])
		for i in range(0, len(args), 2)
		if not found_executable(args[i])
	]


def report_missing_execs(missing_list):
	"""Reports missing executables, returning `True` if there is at least one
	missing and `False` otherwise.

	"""

	def print_missing_list(pre_msg, post_msg, missing):
		if len(missing) == 1:
			output = missing[0]
		else:
			missing_butlast = missing[:-1]
			missing_last    = missing[-1]
			before_last     = ", ".join(missing_butlast)
			comma           = "," if len(missing) > 2 else ""

			output = "{}{} and {}".format(before_last, comma, missing_last)

		sys.stdout.write("{}{} {}\n".format(pre_msg, output, post_msg))

	def notify_missing(missing):
		os.system("notify-send --urgency=critical 'Missing Software' 'Missing execs: {}'".format(', '.join(missing)))

	if len(missing_list) == 0:
		return False
	else:
		print_missing_list(
			pre_msg="",
			post_msg="not found",
			missing=[x['executable'] for x in missing_list],
		)
		print_missing_list(
			pre_msg="Make sure you have ",
			post_msg="installed",
			missing=[x['program'] for x in missing_list],
		)
		notify_missing(x['executable'] for x in missing_list)
		return True


main()

----

=== `prefix` - prefixes all lines read from stdin with a string

.file::prefix
[source,sh]
----
#!/usr/bin/env rc

#
# Prefixes all lines read from stdin.
#

prefix=$1 {
	if (test $#prefix -eq 0) {
		prefix='# '
	}
	sed 's/^/'^$prefix^'/g'
}

----

=== `pretty-print-json`

.file::pretty-print-json
[source,sh]
----
#!/usr/bin/env bash

python -m json.tool "$@"

----

=== `psx` - `ps -ef | grep --color "$@"`

.file::psx
[source,sh]
----
#!/usr/bin/env bash

ps -ef | grep --color "$@"

----

=== `py2` - runs Python 2 in a http://docs.python-guide.org/en/latest/dev/virtualenvs/[virtual environment]

The name of the virtual environment could be set by setting the `VIRTUAL_ENV`
environment variable.  By default, it uses `python2-full-debian` as its name.

.file::py2
[source,sh]
----
#!/usr/bin/env bash

virtualenv_=${VIRTUAL_ENV:-python2-full-debian}

source "${WORKON_HOME}/${virtualenv_}/bin/activate"
exec python "$@"

----

=== `py3` - runs Python 3 in a http://docs.python-guide.org/en/latest/dev/virtualenvs/[virtual environment]

The name of the virtual environment could be set by setting the `VIRTUAL_ENV`
environment variable.  By default, it uses `python2-full-debian` as its name.

.file::py3
[source,sh]
----
#!/usr/bin/env bash

virtualenv_=${VIRTUAL_ENV:-python2-full-debian}

source "${WORKON_HOME}/${virtualenv_}/bin/activate"
exec python3 "$@"

----

=== `site-packages-path` - prints Python site packages path

.file::site-packages-path
[source,sh]
----
#!/usr/bin/env python

from distutils.sysconfig import get_python_lib


print(get_python_lib())

----

=== `qrcode` - creates QR code from a string

.file::qrcode
[source,sh]
----
#!/usr/bin/env rc

report-missing-executables \
	tempfile "tempfile utility" \
	qrencode Qrencode \
	|| exit 1

# FIXME: Not working
if (test $#* -eq 0) {
	echo No argument found
}

tmpfile=`{tempfile}^.png

qrencode -o $tmpfile -s 5 $*
do-notify-short $tmpfile' created'
display $tmpfile

----

=== `rackjure` - runs Racket with https://github.com/greghendershott/rackjure[Rackjure]

.file::rackjure
[source,sh]
----
#!/usr/bin/env bash

racket -I rackjure "$@"

----

=== `system-temperature`

.file::system-temperature
[source,sh]
----
#!/usr/bin/env bash

echo "-> Starting HDDTemp if necessary"
nc localhost 7634 &>/dev/null || (
	exec sudo hddtemp -d /dev/sda
)
echo ""

echo "-> HDD temperature"
nc localhost 7634

echo "-> CPU temperature"
sensors

----

=== `running-p` - determines if a process is running

.file::running-p
[source,sh]
----
#!/usr/bin/env bash

#
# Determines if a process is running using pgrep.
#

exec pgrep "$@" &>/dev/null

----

=== `show-keyboard` - shows keyboard of modifiers, convenient when making screencast

.file::show-keyboard
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables key-mon key-mon || exit 1

key-mon --decorated --meta --theme modern "$@"

----

=== `with-sudo` - runs `sudo` with some environment variables preserved

.file::with-sudo
[source,sh]
----
#!/usr/bin/env sh

if ! sudo --help >/dev/null 2>&1; then
	echo "sudo not found, please install sudo" >&2
	exit 1
fi

exec sudo -E env "PATH=${PATH}" "$@"

----

=== `with-all-x-displays` - runs a command with all X displays

.file::with-all-x-displays
[source,tcl]
----
#!/usr/bin/env tclsh

if {[catch {exec report-missing-executables awk Awk ag Ag >@ stdout 2>@ stderr}]} {
    exit 1
}

proc usage {{outFD stdout}} {
    puts $outFD {with-all-x-displays <command> [args...]

Run a command with all Xorg displays.}
}

if {$::argc == 0} {
    usage stderr
    exit 1
} elseif {[lindex $::argv 0] eq "--help"} {
    usage
    exit 0
}

set displays [string trim [exec w | awk {{ print $3 }} | sort | uniq | ag {^:} <@ stdin]]

foreach display $displays {
    exec env "DISPLAY=$display" {*}$::argv <@ stdin >@ stdout 2>@ stderr
}

----

=== `sudo-askpass` - runs `sudo` with a graphical askpass program, also preserving some environment variables

.file::sudo-askpass
[source,sh]
----
#!/usr/bin/env sh

if ! sudo --help >/dev/null 2>&1; then
	echo "sudo not found, please install sudo" >&2
	exit 1
fi

export SUDO_ASKPASS=${SUDO_ASKPASS:-$(which ssh-askpass)}
export DISPLAY=${DISPLAY:-":0"}

exec sudo --askpass -tt -E env "PATH=${PATH}" "$@"

----

=== `suspend-me` - suspends computer

.file::suspend-me
[source,sh]
----
#!/usr/bin/env bash

# exec sudo pm-suspend && lockscreen
exec sudo pm-suspend

----

=== `take-from` - takes all lines from stdin, starting from a pattern

.file::take-from
[source,sh]
----
#!/usr/bin/env rc

#
# Takes all lines from a pattern (representing by $1), using GNU Awk.
#

gawk 'BEGIN {
	found = 0
}
/'^$1^'/ {
	found = 1
}
{
	if (found == 1) {
		print $0
	}
}'

----

=== `take-lines` - takes the first `n` lines

.file::take-lines
[source,sh]
----
#!/usr/bin/env rc

#
# Takes the first $1 lines using Plan 9's seq.
#

if (test $#* -eq 0) {
	n_lines=1
}
if not {
	n_lines=$1
}
sed $n_lines^q

----

=== `update-openjdk-8-font-patched` - for Debian/Ubuntu

Updates OpenJDK 8 with font rendering patch from PPA
[no1wantdthisname](https://launchpad.net/~no1wantdthisname/+archive/ubuntu/openjdk-fontfix).

.file::update-openjdk-8-font-patched
[source,sh]
----
#!/usr/bin/env rc

repo_url=http://ppa.launchpad.net/no1wantdthisname/openjdk-fontfix/ubuntu/pool/main/o/openjdk-8/
echo URL: $repo_url

latest_version=`{lynx -dump $repo_url \
	| grep '.deb' \
	| awk '{ print $2 }' \
	| sort \
	| tail -1 \
	| awk 'BEGIN { FS="/" } { print $NF }' \
	| awk 'BEGIN { FS="source_" } { print $2 }' \
	| awk 'BEGIN { FS=".deb" } { print $1 }' \
	| gnu-sed 's/_all//g'}
echo Latest version: $latest_version


current_version=`{apt-cache show openjdk-8-jdk \
	| gnu-sed -n '/installed/,+10p' \
	| grep Version \
	| awk '{ print $2 }'}
echo Current version: $current_version

if (~ $latest_version $current_version) {
	echo You have the latest version!
}
if not {
	echo Version mismatch, downloading and installing JDK 8
	debs=`{lynx -dump $repo_url \
		| grep $latest_version \
		| grep 'amd64.*\.deb$' \
		| awk '{ print $2 }'}

	temp_dir=/tmp/openjdk-deb-tmp
	echo Temp directory: $temp_dir
	mkdir -p $temp_dir
	cd $temp_dir
	for (deb in $debs) axel $deb

	echo Installing
	sudo dpkg -i *.deb
}

----

=== `wget-site`

.file::wget-site
[source,sh]
----
#!/usr/bin/env bash

wget \
	--recursive \
	--no-clobber \
	--page-requisites \
	--html-extension \
	--convert-links \
	--timestamping \
	--no-parent \
	--mirror \
	"$@"

#
# --recursive             download the entire Web site.
# --domains website.org   don't follow links outside website.org.
# --no-parent             don't follow links outside the directory tutorials/html/.
# --page-requisites       get all the elements that compose the page (images, CSS and so on).
# --html-extension        save files with the .html extension.
# --convert-links         convert links so that they work locally, off-line.
# --no-clobber            don't overwrite any existing files (used in case the download is interrupted and
#                         resumed).
# --mirror                create mirror
#

----

=== `start-xephyr` - starts a Xephyr server (for debugging window manager)

TODO: Help text

.file::start-xephyr
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables Xephyr Xephyr || exit 1

resolution_=${RESOLUTION:-800x600}

Xephyr \
	-ac \
	-br \
	-noreset \
	-screen ${resolution_} \
	:1 "$@" >/dev/null & disown

# export DISPLAY=:1.0
echo Display: $DISPLAY

----

=== `openfile-dialog` - creates a open-file dialog and prints the selected path to stdout

.file::openfile-dialog
[source,sh]
----
#!/usr/bin/env bash

report-missing-executables zenity Zenity || exit 1

zenity --file-selection --filename `pwd` "$@" 2>/dev/null

----

=== `compute-checksum-url` - computes checksum for remote file

`compute-checksum-url <checksum-tool> <uri> [curl-options] ...`

E.g.

* Compute MD5 sum for https://picsum.photos/200: `compute-checksum-url md5sum https://picsum.photos/200`

* Compute SHA1 sum for https://picsum.photos/200: `compute-checksum-url sha1sum https://picsum.photos/200`

.file::compute-checksum-url
[source,sh]
----
#!/usr/bin/env sh

checksum_tool_="${1}"
shift

report-missing-executables curl cURL "${checksum_tool_}" "${checksum_tool_}" || exit 1

exec curl --silent --location "$@" | "${checksum_tool_}" | cut -d ' ' -f 1

----

=== `smart-download` - downloads file, prompts overwriting, and compares checksums

Downloads a file, compares checksums, and prompts overwriting when necessary.  This script returns the download destination as the last line upon a successful download with exit code 0.  In case of error or checksums not matching, a non-zero exit code is returned.  This script leverages the MD5 sum, SHA1 sum, SHA256 sum from Coreutils.

E.g.

* Download to a temporary file:
+
[source,sh]
----
smart-download https://picsum.photos/200
----

* Download to `/tmp/aoeu`, prompt overwriting:
+
[source,sh]
----
smart-download --destination /tmp/aoeu https://picsum.photos/200
----

* If the current MD5 sum of `/tmp/aoeu` doesn't match `ABC`, download and overwrite it, then compute and the check the MD5 sum for the downloaded file; otherwise, skip the download:
+
[source,sh]
----
smart-download --destination /tmp/aoeu --md5sum ABC https://picsum.photos/200
----

* Same as the previous example except that the SHA1 sum is taken into account along with the MD5 sum:
+
[source,sh]
----
smart-download --destination /tmp/aoeu --md5sum ABC --sha1sum DEF https://picsum.photos/200
----

.file::smart-download
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tcl 8.2
package require fileutil

try {
	array set args [::cmdline::getoptions ::argv {
		{destination.arg "" "(optional) The download destination"}
		{md5sum.arg      "" "(optional) The MD5 checksum"}
		{sha1sum.arg     "" "(optional) The SHA1 checksum"}
		{sha256sum.arg   "" "(optional) The SHA256 checksum"}
		{sha512sum.arg   "" "(optional) The SHA512 checksum"}
	} {[options] <uri>

Download a file, compare checksum if necessary, and return the path to the downloaded file.  If the download destination is not specified, a temporary path is returned.
}]
} trap {CMDLINE USAGE} {msg _o} {
	puts $msg
	exit 0
}

if {[catch {exec report-missing-executables aria2c Aria2c >@ stdout 2>@ stderr}]} {
	exit 1
}

proc getDestination {dest} {
	if {$dest eq ""} {
		set path [::fileutil::tempfile]
		file delete -- $path
		return $path
	} else {
		return $dest
	}
}

proc getURI {uri} {
	if {$uri eq ""} {
		puts stderr "URI must be provided"
		exit 1
	} else {
		return $uri
	}
}

proc checksumsMatched {path checksumDict} {
	proc checksumMatched {path type checksum} {
		set checksum [string toupper $checksum]
		if {$checksum eq ""} {
			return 1
		} else {
			switch $type {
				md5 {
					return [expr {$checksum eq [string toupper [exec md5sum $path | cut -f1 -d " "]]}]
				}
				sha1 {
					return [expr {$checksum eq [string toupper [exec sha1sum $path | cut -f1 -d " "]]}]
				}
				sha256 {
					return [expr {$checksum eq [string toupper [exec sha256sum $path | cut -f1 -d " "]]}]
				}
				sha512 {
					return [expr {$checksum eq [string toupper [exec sha512sum $path | cut -f1 -d " "]]}]
				}
				default {
					return 1
				}
			}
		}
	}
	return [expr {[checksumMatched $path md5 [dict get $checksumDict md5sum]]
				  && [checksumMatched $path sha1 [dict get $checksumDict sha1sum]]
				  && [checksumMatched $path sha256 [dict get $checksumDict sha256sum]]
				  && [checksumMatched $path sha512 [dict get $checksumDict sha512sum]]}]
}

proc downloadFile {destDir destFile uri} {
	return [exec aria2c --dir $destDir --out $destFile $uri >@ stdout 2>@ stderr]
}

set dest [getDestination $args(destination)]
set destDir [file dirname $dest]
set destFile [file tail $dest]
set uri [getURI [lindex $::argv 0]]
set checksumDict [dict create md5sum $args(md5sum) sha1sum $args(sha1sum) sha256sum $args(sha256sum) sha512sum $args(sha512sum)]

if {[lindex [array get ::env VERBOSE] 1] == 1} {
	# Be verbose
	parray args
	puts "Destination: $dest"
	puts "URI: $uri"
}

if {[file exists $dest]} {
	if {[dict values $checksumDict] == {{} {} {}}} {
		try {
			exec prompt-y-n "$dest exists, would you like continue and overwrite it?" y <@ stdin >@ stdout 2>@ stderr
			file delete -- $dest
			downloadFile $destDir $destFile $uri
		} trap CHILDSTATUS {_msg _options} {}
	} elseif {![checksumsMatched $dest $checksumDict]} {
		file delete -- $dest
		downloadFile $destDir $destFile $uri
	}
} else {
	downloadFile $destDir $destFile $uri
}

if {![checksumsMatched $dest $checksumDict]} {
	exit 1
} else {
	puts $dest
}

# Local Variables:
# indent-tabs-mode: t
# End:

----

=== `random-string` - generates a random alphanumeric string

.file::random-string
[source,sh]
----
#!/usr/bin/env bash

length_=${1:-32}

cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${length_} | head -n 1

----

=== `daemontools`-compatible utils

==== `sv-create-user-supervisor` - creates a supervision daemon for the current user

.file::sv-create-user-supervisor
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

## include::tcl-helpers

##############################################################################
# Helpers
##############################################################################

proc execCmd {args} {
     return [exec {*}$args <@ stdin >@ stdout 2>@ stderr]
}

proc getRunsvdirLogContent {servicePath} {
    return [format {#!/usr/bin/env sh

mkdir -p %s/log/main
exec svlogd -ttt %s/log/main
} $servicePath $servicePath]
}

proc getRunsvdirContent {user userDaemonEnableDir} {
    return [format {#!/usr/bin/env sh

exec 2>&1
exec sudo -H -E -u %s runsvdir -P %s
} $user $userDaemonEnableDir]
}

proc createExecutableAsRoot {path content} {
    if {[file exists $path]} {
        puts -nonewline "$path exists, remove it? \[y/N\] "
        flush stdout
        set answer [string tolower [string trim [gets stdin]]]
        if {$answer eq "y"} {
            execCmd with-sudo rm -rvI $path
        } else {
            exit 0
        }
    }

    file tempfile tempFile /tmp/tempfile

    set f [open $tempFile w]
    puts $f $content
    close $f

    execCmd with-sudo mv $tempFile $path
    execCmd with-sudo chmod +x $path
}

##############################################################################
# Main
##############################################################################

if {$argc == 0} {
    set user $::env(USER)
} else {
    set user [lindex $argv 0]
}

if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonDir $::env(MY_DAEMON_DIR)
} else {
    set userDaemonDir /home/$user/daemon
}

set userDaemonEnableDir $userDaemonDir/enabled
set userDaemonAvailableDir $userDaemonDir/available
set serviceName runsvdir-$user
set servicePath /etc/sv/$serviceName

puts "User: $user"
puts "Supervisor service path: $servicePath"
puts "User service path (available): $userDaemonAvailableDir"
puts "User service path (enabled): $userDaemonEnableDir"
puts ""

execCmd with-sudo mkdir -p $servicePath/log/main
file mkdir $userDaemonAvailableDir
file mkdir $userDaemonEnableDir

createExecutableAsRoot $servicePath/run     [getRunsvdirContent $user $userDaemonEnableDir]
createExecutableAsRoot $servicePath/log/run [getRunsvdirLogContent $servicePath]

exec with-sudo symlink $servicePath /etc/service/$serviceName

puts "Done, please restart the Runit service"

----

==== `sv-enable` - enables a daemon

.file::sv-enable
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text

set serviceName [lindex $argv 0]
if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonPath $::env(MY_DAEMON_DIR)
} else {
    set userDaemonPath [file normalize ~/daemon]
}

set servicePath [glob -nocomplain $userDaemonPath/available/$serviceName]
set enablePath $userDaemonPath/enabled/$serviceName

if {$servicePath eq ""} {
    puts stderr "Error: $servicePath doesn't exist"
    exit 1
}

exec symlink $servicePath $enablePath <@ stdin >@ stdout 2>@ stderr

----

==== `sv-disable` - disables a daemon

.file::sv-disable
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text

set serviceName [lindex $argv 0]
if {[info exists ::env(MY_DAEMON_DIR)]} {
    set userDaemonPath $::env(MY_DAEMON_DIR)
} else {
    set userDaemonPath [file normalize ~/daemon]
}

set enablePath [glob -nocomplain $userDaemonPath/enabled/$serviceName]

if {$enablePath ne ""} {
    file delete $enablePath
}

----

==== `sv-list` - lists current daemons

.file::sv-list
[source,tcl]
----
#!/usr/bin/env tclsh

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

if {$::env(USER) eq "root"} {
    set supervisedPath /etc/service
} else {
    if {[info exists ::env(MY_DAEMON_DIR)]} {
        set supervisedPath $::env(MY_DAEMON_DIR)/enabled
    } else {
        set supervisedPath [file normalize ~/daemon/enabled]
    }
}

foreach dir [glob -nocomplain $supervisedPath/*] {
    puts [file tail $dir]
}

----

==== `sv-tail-log` - tails a log file for a daemon

.file::sv-tail-log
[source,tcl]
----
#!/usr/bin/env tclsh

package require Tclx

# TODO: matching -h/--help
# TODO: help text
# TODO: command line arguments

set serviceName [lindex $::argv 0]
set logFile [lindex $::argv 1]

if {$::env(USER) eq "root"} {
    set supervisedPath /etc/service
} else {
    if {[info exists ::env(MY_DAEMON_DIR)]} {
        set supervisedPath $::env(MY_DAEMON_DIR)/enabled
    } else {
        set supervisedPath [file normalize ~/daemon/enabled]
    }
}

execl tail [list "-f" $supervisedPath/$serviceName/log/main/$logFile]

----

== Legacy/Unused scripts

=== `i3-switch-window` - window switcher for http://i3wm.org/[i3]

Requirement: `dmenu`.

[source,python]
----
#!/usr/bin/env python3

#
# Copyright (C) 2015-2016  Ha-Duong Nguyen <cmpitg@gmail.com>
#
# i3-switch-window is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# i3-switch-window is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# i3-switch-window.  If not, see <http://www.gnu.org/licenses/>.
#

#
# Requirements:
#   Python 3
#   dmenu with Xft patch
#

import json
import subprocess
import sys


# dmenu_options      = '-b -i -l 40 -fn "Noto Sans-10" -nf "#ffa077" -nb "#202020"'
dmenu_options      = '-p Window -i -l 40 -fn "Noto Sans-10" -nf "#ffa077" -nb "#202020"'
title_format       = "{} — {}"
cmd_get_tree       = "i3-msg -t get_tree"
cmd_switch_window  = "i3-msg '[con_id={}] focus'"


def main():
	fail_if_dmenu_not_found()

	global dmenu_options
	global cmd_get_tree
	global cmd_switch_window

	tree = json.loads(subprocess.check_output(
		cmd_get_tree,
		stderr=subprocess.STDOUT,
		shell=True
	).decode('utf-8'))

	windows       = get_all_windows(tree)
	lookup_table  = build_lookup_table(windows)
	chosen        = dmenu(itemize(windows), dmenu_options)

	switch_to_window(
		chosen=chosen,
		table=lookup_table,
		cmd=cmd_switch_window
	)


def fail_if_dmenu_not_found():
	"""Check if dmenu exists and exit if it doesn't."""
	if subprocess.call("which dmenu", shell=True) != 0:
		sys.stdout.write("dmenu not found\n")
		sys.stdout.write("Make sure you have dmenu installed\n")
		sys.exit(1)


def switch_to_window(chosen, table, cmd):
	"""Switch to the chosen window."""
	window_id = table.get(chosen, -1)
	if window_id != -1:
		subprocess.check_call(cmd.format(window_id), shell=True)


def window_as_string(with_id=False):
	global title_format

	def helper(window):
		title = title_format.format(window['class'], window['title'])
		if with_id:
			return title, window['id']
		else:
			return title

	return helper


def build_lookup_table(windows):
	stringifized = map(window_as_string(with_id=True), windows)
	return dict(stringifized)


def itemize(windows):
	"""Itemize windows list for dmenu."""
	return "\n".join(map(window_as_string(with_id=False), windows))


def get_all_windows(tree):
	"""Extracts all windows from i3 tree."""
	# Add current window
	if is_window(tree):
		result = [standardize_window(tree)]
	else:
		result = []

	# Add child windows
	children = []
	for window in tree['nodes']:
		children += get_all_windows(window)

	return result + children


def is_window(tree):
	"""Determines if a tree is a window."""
	return tree['window'] \
		and tree['window_properties']['class'].lower().find('panel') == -1


def standardize_window(window):
	"""Extracts necessary information for a window."""
	return {
		'id':       window['id'],
		'title':    window['window_properties']['title'],
		'class':    window['window_properties']['class'],
		'instance': window['window_properties']['instance']
	}


def dmenu(items, dmenu_options):
	"""Calls dmenu to display and menu for window switching."""
	cmd = subprocess.Popen(
		"dmenu {}".format(dmenu_options),
		shell=True,
		stdin=subprocess.PIPE,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE
	)
	stdout, _ = cmd.communicate(items.encode('utf-8'))
	return stdout.decode('utf-8').strip('\n')


if __name__ == '__main__':
	main()

----

== License

This project is released under the terms of the FreeBSD license.  See `LICENSE` for further information.
